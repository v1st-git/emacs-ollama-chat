{"task_id": "Emacs Lisp/1", "prompt": "(require 'cl-lib)\n\n(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;False\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;True", "canonical_solution": "(cl-loop for i from 0 below (length numbers)\nthereis (cl-loop for j from 0 below (length numbers)\nwhen (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\nreturn t)))", "test": ";; Test cases\n(defun check-has-close-elements ()\n(cl-assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(cl-assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(cl-assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(cl-assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(cl-assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(cl-assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(cl-assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)", "entry_point": "has-close-elements", "signature": "(defun has-close-elements (numbers threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Write a Emacs Lisp function `(defun has-close-elements (numbers threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "level": "easy", "raw_generation":"(defun has-close-elements (numbers threshold)\n  \"Check if any two elements in NUMBERS differ by less than THRESHOLD.\"\n  (let ((sorted-numbers (sort (copy-sequence numbers) 'float<))) ; Sort a copy of the list\n    (cl-loop for (a b) on sorted-numbers while b always (> (- b a) threshold))))"}
{"task_id": "Emacs Lisp/2", "prompt": "(require 'cl-lib) (defun longest-harmonious-subsequence (nums)\n;; Function to find the longest harmonious subsequence in a list of numbers.\n;; A harmonious subsequence is one where the difference between max and min elements is exactly 1.\n;; Args:\n;; nums: A list of integers.\n;; Returns:\n;; The length of the longest harmonious subsequence.\n;; Example Usage:\n;; (longest-harmonious-subsequence '(1 3 2 2 5 2 3 7) ; Returns 5\n;; (longest-harmonious-subsequence '(1 2 3 4) Returns 2", "canonical_solution": "(let ((num-counts (make-hash-table :test 'equal)))\n;; Count the occurrences of each number.\n(dolist (num nums)\n(puthash num (1+ (gethash num num-counts 0)) num-counts))\n\n(let ((max-length 0))\n;; Check each number and its neighbor (+1) to find the longest subsequence.\n(maphash (lambda (key value)\n(let ((neighbor (gethash (1+ key) num-counts)))\n(when neighbor\n(setq max-length (max max-length (+ value neighbor)))))\n) num-counts)\nmax-length)))", "test": "(defun check-longest-harmonious-subsequence ()\n(cl-assert (equal (longest-harmonious-subsequence '(1 3 2 2 5 2 3 7)) 5))\n(cl-assert (equal (longest-harmonious-subsequence '(1 2 3 4)) 2))\n(cl-assert (equal (longest-harmonious-subsequence '(1 1 1 1)) 0))\n(cl-assert (equal (longest-harmonious-subsequence '()) 0))\n(cl-assert (equal (longest-harmonious-subsequence '(1)) 0)))\n\n(check-longest-harmonious-subsequence)", "entry_point": "longest-harmonious-subsequence", "signature": "(defun longest-harmonious-subsequence (nums)", "docstring": "Function to find the longest harmonious subsequence in a list of numbers.\nA harmonious subsequence is one where the difference between max and min elements is exactly 1.\nArgs:\nnums: A list of integers.\nReturns:\nThe length of the longest harmonious subsequence.\nExample Usage:\n(longest-harmonious-subsequence '(1 3 2 2 5 2 3 7) ; Returns 5\n(longest-harmonious-subsequence '(1 2 3 4) Returns 2", "instruction": "Write a Emacs Lisp function `(defun longest-harmonious-subsequence (nums)` to solve the following problem:\nFunction to find the longest harmonious subsequence in a list of numbers.\nA harmonious subsequence is one where the difference between max and min elements is exactly 1.\nArgs:\nnums: A list of integers.\nReturns:\nThe length of the longest harmonious subsequence.\nExample Usage:\n(longest-harmonious-subsequence '(1 3 2 2 5 2 3 7) ; Returns 5\n(longest-harmonious-subsequence '(1 2 3 4) Returns 2", "level": "middle", "raw_generation":"(defun longest-harmonious-subsequence (nums)\n  \"Find the length of the longest harmonious subsequence in Nums.\"\n  (let ((freq-table (make-hash-table :test 'equal))\n        max-length)\n    \n    ;; Build a frequency table for each number.\n    (dolist (num nums)\n      (puthash num (1+ (gethash num freq-table 0)) freq-table))\n\n    ;; Iterate over the keys to find harmonious pairs.\n    (maphash (lambda (key val)\n               (when (and (gethash (+ key 1) freq-table)\n                          (> (+ val (gethash (+ key 1) freq-table)) max-length))\n                 (setq max-length (+ val (gethash (+ key 1) freq-table)))))\n             freq-table)\n    \n    ;; Return the maximum length found.\n    (or max-length 0)))"}
{"task_id": "Emacs Lisp/3", "prompt": "(require 'cl-lib)\n(defun count-max-after-ops (m n ops)\n;; generate elisp code\n;; Function to find the count of the maximum integer in a m x n matrix after applying operations.\n;; Args:\n;; m: Number of rows in the matrix.\n;; n: Number of columns in the matrix.\n;; ops: List of operations, where each operation is a list [ai, bi].\n;; Returns:\n;; The count of the maximum integer in the matrix after applying all operations.\n;; count-max-after-ops 3 3 '((2 2) (3 3)) ; Returns 4\n;; count-max-after-ops 3 3 '((2 2) (3 1)) ; Returns 2", "canonical_solution": "(let ((min-row m) (min-col n))\n;; For each operation, update the minimum row and column.\n(dolist (op ops)\n(setq min-row (min min-row (car op)))\n(setq min-col (min min-col (cadr op))))\n;; The count of max integer is the product of min-row and min-col.\n(* min-row min-col)))", "test": "(defun check-count-max-after-ops ()\n(cl-assert (equal (count-max-after-ops 3 3 '((2 2) (3 3))) 4))\n(cl-assert (equal (count-max-after-ops 3 3 '((2 2) (3 1))) 2))\n(cl-assert (equal (count-max-after-ops 4 4 '((1 1) (2 2))) 1))\n(cl-assert (equal (count-max-after-ops 5 5 '()) 25))\n(cl-assert (equal (count-max-after-ops 3 3 '((3 3) (2 2))) 4)))\n\n(check-count-max-after-ops)", "entry_point": "count-max-after-ops", "signature": "(defun count-max-after-ops (m n ops)", "docstring": "generate elisp code\nFunction to find the count of the maximum integer in a m x n matrix after applying operations.\nArgs:\nm: Number of rows in the matrix.\nn: Number of columns in the matrix.\nops: List of operations, where each operation is a list [ai, bi].\nReturns:\nThe count of the maximum integer in the matrix after applying all operations.\ncount-max-after-ops 3 3 '((2 2) (3 3)) ; Returns 4\ncount-max-after-ops 3 3 '((2 2) (3 1)) ; Returns 2", "instruction": "Write a Emacs Lisp function `(defun count-max-after-ops (m n ops)` to solve the following problem:\ngenerate elisp code\nFunction to find the count of the maximum integer in a m x n matrix after applying operations.\nArgs:\nm: Number of rows in the matrix.\nn: Number of columns in the matrix.\nops: List of operations, where each operation is a list [ai, bi].\nReturns:\nThe count of the maximum integer in the matrix after applying all operations.\ncount-max-after-ops 3 3 '((2 2) (3 3)) ; Returns 4\ncount-max-after-ops 3 3 '((2 2) (3 1)) ; Returns 2", "level": "easy", "raw_generation":"(defun count-max-after-ops (m n ops)\n  \"Calculate the number of maximum integers in an m x n matrix after applying the list of operations OPS.\"\n  ;; Initialize min-a and min-b to m and n, respectively.\n  (let ((min-a m)\n        (min-b n))\n    ;; Iterate over each operation [ai, bi].\n    (dolist (op ops)\n      (let ((a (car op))\n            (b (cadr op)))\n        ;; Update min-a and min-b to the smallest dimensions affected.\n        (setq min-a (min min-a a))\n        (setq min-b (min min-b b))))\n    ;; The area of intersection is the count of maximum integers.\n    (* min-a min-b)))"}
{"task_id": "Emacs Lisp/4", "prompt": "(require 'cl-lib)\n\n(defun find-common-favorites (andy-list doris-list)\n;; generate elisp code\n;; Function to find common favorite restaurants with the minimum index sum.\n;; Args:\n;; andy-list: List of strings representing Andy's favorite restaurants.\n;; doris-list: List of strings representing Doris's favorite restaurants.\n;; Returns:\n;; List of restaurant names that are common favorites with the least index sum.\n;; Example\n;; andy-list:(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n;; doris-list:(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\")\n;; return:(\"Shogun\")", "canonical_solution": "(let ((restaurant-index-sum (make-hash-table :test 'equal))\n(min-sum most-positive-fixnum)\ncommon-favorites)\n;; Build a hash table with sums of indices for common restaurants.\n(cl-loop for andy-idx from 0 below (length andy-list)\nfor andy-restaurant = (nth andy-idx andy-list)\ndo (let ((doris-idx (cl-position andy-restaurant doris-list :test 'equal)))\n(when doris-idx\n(let ((sum (+ andy-idx doris-idx)))\n(puthash andy-restaurant sum restaurant-index-sum)\n(setq min-sum (min min-sum sum))))))\n;; Collect restaurants with the minimum index sum.\n(maphash (lambda (restaurant sum)\n(when (= sum min-sum)\n(push restaurant common-favorites)))\nrestaurant-index-sum)\ncommon-favorites))", "test": "(defun check-find-common-favorites ()\n(cl-assert (equal (find-common-favorites '(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n'(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\"))\n'(\"Shogun\")))\n(cl-assert (equal (find-common-favorites '(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n'(\"KFC\" \"Shogun\" \"Burger King\"))\n'(\"Shogun\")))\n(cl-assert (equal (find-common-favorites '(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n'(\"KFC\" \"Burger King\" \"Tapioca Express\" \"Shogun\"))\n'(\"KFC\" \"Burger King\" \"Tapioca Express\" \"Shogun\" )))\n(cl-assert (equal (find-common-favorites '(\"KFC\" \"Shogun\" \"Burger King\")\n'(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\"))\n'(\"Shogun\"))))\n\n(check-find-common-favorites)", "entry_point": "find-common-favorites", "signature": "(defun find-common-favorites (andy-list doris-list)", "docstring": "generate elisp code\nFunction to find common favorite restaurants with the minimum index sum.\nArgs:\nandy-list: List of strings representing Andy's favorite restaurants.\ndoris-list: List of strings representing Doris's favorite restaurants.\nReturns:\nList of restaurant names that are common favorites with the least index sum.\nExample\nandy-list:(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\ndoris-list:(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\")\nreturn:(\"Shogun\")", "instruction": "Write a Emacs Lisp function `(defun find-common-favorites (andy-list doris-list)` to solve the following problem:\ngenerate elisp code\nFunction to find common favorite restaurants with the minimum index sum.\nArgs:\nandy-list: List of strings representing Andy's favorite restaurants.\ndoris-list: List of strings representing Doris's favorite restaurants.\nReturns:\nList of restaurant names that are common favorites with the least index sum.\nExample\nandy-list:(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\ndoris-list:(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\")\nreturn:(\"Shogun\")", "level": "hard", "raw_generation":"(defun find-common-favorites (andy-list doris-list)\n  \"Find common favorite restaurants with minimum index sum.\nANDY-LIST and DORIS-LIST are lists of strings representing favorite restaurants.\"\n  (let ((restaurant-index (make-hash-table :test 'equal))\n        (min-sum most-positive-fixnum)\n        (result nil))\n    \n    ;; Step 1: Create a hash table for Andy's list with index as value\n    (dotimes (i (length andy-list))\n      (puthash (nth i andy-list) i restaurant-index))\n    \n    ;; Step 2: Iterate through Doris' list to find matches\n    (dotimes (j (length doris-list))\n      (let ((restaurant (nth j doris-list)))\n        (when-let (i (gethash restaurant restaurant-index))\n          (let ((index-sum (+ i j)))\n            ;; Update result if we find a smaller sum or equal but lexicographically smaller\n            (cond\n             ((< index-sum min-sum)\n              (setq min-sum index-sum)\n              (setq result (list restaurant)))\n             ((= index-sum min-sum)\n              (push restaurant result)))))))\n    \n    ;; Step 3: Return the sorted result\n    (sort result #'string<)))"}
{"task_id": "Emacs Lisp/5", "prompt": "(require 'cl-lib)\n\n(defun can-plant-flowers (flowerbed n)\n;; generate elisp code\n;; Function to determine if n flowers can be planted without violating the non-adjacency rule.\n;; Args:\n;; flowerbed: List of integers (0 or 1) representing the flowerbed.\n;; n: Integer, the number of flowers to be planted.\n;; Returns:\n;; t if it is possible to plant n flowers, nil otherwise.\n;; Example:\n;; flowerbed: (1 0 0 0 1), n: 1\n;; return: t", "canonical_solution": "(let ((len (length flowerbed))\n(count 0))\n(cl-loop for i from 0 below len do\n(when (and (= (nth i flowerbed) 0)\n(or (= i 0) (/= (nth (1- i) flowerbed) 1))\n(or (= i (1- len)) (/= (nth (1+ i) flowerbed) 1)))\n(setf (nth i flowerbed) 1)\n(setq count (1+ count))))\n(>= count n)))", "test": "(defun check-can-plant-flowers ()\n(cl-assert (equal (can-plant-flowers '(1 0 0 0 1) 1) t))\n(cl-assert (equal (can-plant-flowers '(1 0 0 0 1) 2) nil))\n(cl-assert (equal (can-plant-flowers '(0 0 0 0 0) 3) t))\n(cl-assert (equal (can-plant-flowers '(0 0 1 0 1) 1) t))\n(cl-assert (equal (can-plant-flowers '(1 0 1 0 1 0 1) 0) t))\n(cl-assert (equal (can-plant-flowers '(0) 1) t)))\n\n(check-can-plant-flowers)", "entry_point": "can-plant-flowers", "signature": "(defun can-plant-flowers (flowerbed n)", "docstring": "generate elisp code\nFunction to determine if n flowers can be planted without violating the non-adjacency rule.\nArgs:\nflowerbed: List of integers (0 or 1) representing the flowerbed.\nn: Integer, the number of flowers to be planted.\nReturns:\nt if it is possible to plant n flowers, nil otherwise.\nExample:\nflowerbed: (1 0 0 0 1), n: 1\nreturn: t", "instruction": "Write a Emacs Lisp function `(defun can-plant-flowers (flowerbed n)` to solve the following problem:\ngenerate elisp code\nFunction to determine if n flowers can be planted without violating the non-adjacency rule.\nArgs:\nflowerbed: List of integers (0 or 1) representing the flowerbed.\nn: Integer, the number of flowers to be planted.\nReturns:\nt if it is possible to plant n flowers, nil otherwise.\nExample:\nflowerbed: (1 0 0 0 1), n: 1\nreturn: t", "level": "easy", "raw_generation":"(defun can-plant-flowers (flowerbed n)\n  \"Determine if N flowers can be planted in FLOWERBED without violating the non-adjacency rule.\"\n  (let ((length (length flowerbed)) ; Get length of the flowerbed list\n        (count 0))                ; Initialize count for plantable flowers\n\n    ;; Iterate over each plot in the flowerbed\n    (dotimes (i length)\n      ;; Check if current spot is empty and adjacent spots are also empty or boundaries\n      (when (and (= (nth i flowerbed) 0)           ; Current plot is empty\n                 (or (= i 0) (= (nth (1- i) flowerbed) 0))   ; Previous plot is boundary or empty\n                 (or (= i (1- length)) (= (nth (1+ i) flowerbed) 0))) ; Next plot is boundary or empty\n        \n        ;; Plant a flower here\n        (aset flowerbed i 1)         ; Set current spot to occupied\n\n        ;; Increment count of plantable flowers\n        (cl-incf count)              ; Using cl-incf for safe incrementing\n\n        ;; Check if the required number of flowers have been planted\n        (when (>= count n)\n          (return t))))  ; Early return if we can plant all required flowers\n    \n    ;; If not enough space found, return nil\n    nil))"}
{"task_id": "Emacs Lisp/6", "prompt": "(require 'cl-lib) (defun max-product-of-three (nums)\n;; generate elisp code\n;; Function to find the maximum product of any three numbers in the array.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The maximum product of three numbers.\n;; Example:\n;; nums: (1 2 3 4)\n;; return: 24 (which is 2 * 3 * 4)", "canonical_solution": "(setq nums (sort nums '>))\n;; The maximum product can be the product of the three largest numbers\n;; or the product of the two smallest numbers (if they are negative) and the largest number.\n(max (* (nth 0 nums) (nth 1 nums) (nth 2 nums))\n(* (nth 0 nums) (nth (- (length nums) 1) nums) (nth (- (length nums) 2) nums))))", "test": "(defun check-max-product-of-three ()\n(cl-assert (equal (max-product-of-three '(1 2 3 4)) 24))\n(cl-assert (equal (max-product-of-three '(-1 -2 -3 4)) 24))\n(cl-assert (equal (max-product-of-three '(-4 -3 -2 -1 60)) 720))\n(cl-assert (equal (max-product-of-three '(1 1 1 1)) 1))\n(cl-assert (equal (max-product-of-three '(-1 -2 -3)) -6))\n(cl-assert (equal (max-product-of-three '(-1 0 2 3 4)) 24)))\n\n(check-max-product-of-three)", "entry_point": "max-product-of-three", "signature": "(defun max-product-of-three (nums)", "docstring": "generate elisp code\nFunction to find the maximum product of any three numbers in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe maximum product of three numbers.\nExample:\nnums: (1 2 3 4)\nreturn: 24 (which is 2 * 3 * 4)", "instruction": "Write a Emacs Lisp function `(defun max-product-of-three (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the maximum product of any three numbers in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe maximum product of three numbers.\nExample:\nnums: (1 2 3 4)\nreturn: 24 (which is 2 * 3 * 4)", "level": "easy", "raw_generation":"(defun max-product-of-three (nums)\n  \"Return the maximum product of any three numbers in the list NUMS.\"\n  (let* ((sorted-nums (sort (copy-sequence nums) #'<))\n         (n (length sorted-nums)))\n    ;; The maximum product can be either:\n    ;; 1. Product of the three largest numbers\n    ;; 2. Product of two smallest and one largest number (for negatives)\n    (max (* (nth (- n 3) sorted-nums) \n            (nth (- n 2) sorted-nums) \n            (nth (- n 1) sorted-nums))\n         (* (nth 0 sorted-nums)\n            (nth 1 sorted-nums)\n            (nth (- n 1) sorted-nums)))))"}
{"task_id": "Emacs Lisp/7", "prompt": "(require 'cl-lib)\n\n(defun find-error-nums (nums)\n;; generate elisp code\n;; Function to find the duplicated and missing numbers in the array.\n;; Args:\n;; nums: List of integers representing the erroneous set.\n;; Returns:\n;; List containing the duplicated number and the missing number.\n;; Example:\n;; nums: (1 2 2 4)\n;; return: (2 3)", "canonical_solution": "(let ((num-counts (make-hash-table :test 'equal))\n(n (length nums))\nduplicate missing)\n;; Count the occurrences of each number.\n(dolist (num nums)\n(puthash num (1+ (or (gethash num num-counts) 0)) num-counts))\n;; Find the duplicate and missing numbers.\n(dotimes (i n)\n(let ((count (gethash (1+ i) num-counts)))\n(cond ((and count (= count 2)) (setq duplicate (1+ i)))\n((not count) (setq missing (1+ i))))))\n(list duplicate missing)))", "test": "(defun check-find-error-nums ()\n(cl-assert (equal (find-error-nums '(1 2 2 4)) '(2 3)))\n(cl-assert (equal (find-error-nums '(1 3 3)) '(3 2)))\n(cl-assert (equal (find-error-nums '(2 2)) '(2 1)))\n(cl-assert (equal (find-error-nums '(1 5 3 2 2 4)) '(2 6)))\n(cl-assert (equal (find-error-nums '(1 1)) '(1 2))))\n\n(check-find-error-nums)", "entry_point": "find-error-nums", "signature": "(defun find-error-nums (nums)", "docstring": "generate elisp code\nFunction to find the duplicated and missing numbers in the array.\nArgs:\nnums: List of integers representing the erroneous set.\nReturns:\nList containing the duplicated number and the missing number.\nExample:\nnums: (1 2 2 4)\nreturn: (2 3)", "instruction": "Write a Emacs Lisp function `(defun find-error-nums (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the duplicated and missing numbers in the array.\nArgs:\nnums: List of integers representing the erroneous set.\nReturns:\nList containing the duplicated number and the missing number.\nExample:\nnums: (1 2 2 4)\nreturn: (2 3)", "level": "middle", "raw_generation":"(defun find-error-nums (nums)\n  \"Find the duplicated and missing numbers in the array NUMs.\nReturns a list containing the duplicated number and the missing number.\"\n  (let ((len (length nums))\n        (sum 0)\n        (square-sum 0)\n        (expected-sum (/ (* len (+ len 1)) 2))\n        (expected-square-sum (/ (* len (+ len 1) (+ (* 2 len) 1)) 6)))\n    (dolist (num nums)\n      (setq sum (+ sum num))\n      (setq square-sum (+ square-sum (* num num))))\n    (let* ((sum-diff (- expected-sum sum))           ;; missing - duplicate = x - y\n           (square-sum-diff (- expected-square-sum square-sum)) ;; missing^2 - duplicate^2 = x^2 - y^2\n           (missing-plus-duplicate (/ square-sum-diff sum-diff))) ;; (x + y) = (x^2 - y^2)/(x - y)\n      (let ((duplicate (/ (+ missing-plus-duplicate (- sum-diff)) 2))\n            (missing (/ (- missing-plus-duplicate sum-diff) 2)))\n        (list duplicate missing)))))"}
{"task_id": "Emacs Lisp/8", "prompt": "(require 'cl-lib)\n\n(defun find-length-of-longest-increasing-subseq (nums)\n;; generate elisp code\n;; Function to find the length of the longest consecutive increasing subsequence.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The length of the longest consecutive increasing subsequence.\n;; Example:\n;; nums: (1 3 5 4 7)\n;; return: 3 (The longest increasing subsequence is [1, 3, 5])", "canonical_solution": "(if (null nums)\n0 ; Return 0 for empty list\n(let ((max-length 0) (current-length 1))\n(cl-loop for i from 1 below (length nums) do\n(if (< (nth (1- i) nums) (nth i nums))\n(setq current-length (1+ current-length))\n(setq max-length (max max-length current-length))\n(setq current-length 1)))\n(max max-length current-length))))", "test": "(defun check-find-length-of-longest-increasing-subseq ()\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(1 3 5 4 7)) 3))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(2 2 2 2 2)) 1))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(1 2 3 4 5)) 5))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(5 4 3 2 1)) 1))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '()) 0)))\n\n(check-find-length-of-longest-increasing-subseq)", "entry_point": "find-length-of-longest-increasing-subseq", "signature": "(defun find-length-of-longest-increasing-subseq (nums)", "docstring": "generate elisp code\nFunction to find the length of the longest consecutive increasing subsequence.\nArgs:\nnums: List of integers.\nReturns:\nThe length of the longest consecutive increasing subsequence.\nExample:\nnums: (1 3 5 4 7)\nreturn: 3 (The longest increasing subsequence is [1, 3, 5])", "instruction": "Write a Emacs Lisp function `(defun find-length-of-longest-increasing-subseq (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the length of the longest consecutive increasing subsequence.\nArgs:\nnums: List of integers.\nReturns:\nThe length of the longest consecutive increasing subsequence.\nExample:\nnums: (1 3 5 4 7)\nreturn: 3 (The longest increasing subsequence is [1, 3, 5])", "level": "easy", "raw_generation":"(defun find-length-of-longest-increasing-subseq (nums)\n  \"Find the length of the longest consecutive increasing subsequence in NUMS.\"\n  (if (null nums)\n      0\n    ;; Initialize variables to keep track of the maximum and current lengths.\n    (let ((max-len 1)\n          (current-len 1))\n      ;; Iterate through the list, starting from the second element.\n      (dolist (num (cdr nums))\n        ;; Check if the current number is greater than the previous one.\n        (if (> num (car (last nums)))\n            (setq current-len (1+ current-len))\n          ;; If not, update max-len and reset current-len to 1.\n          (progn\n            (when (> current-len max-len)\n              (setq max-len current-len))\n            (setq current-len 1))))\n      ;; Final check in case the longest subsequence is at the end of the list.\n      (if (> current-len max-len)\n          (setq max-len current-len))\n      ;; Return the maximum length found.\n      max-len)))"}
{"task_id": "Emacs Lisp/9", "prompt": "(require 'cl-lib)\n\n(defun find-shortest-subarray-with-same-degree (nums)\n;; generate elisp code\n;; Function to find the length of the shortest subarray with the same degree as the original array.\n;; Args:\n;; nums: List of non-negative integers.\n;; Returns:\n;; The length of the shortest subarray with the same degree.\n;; Example:\n;; nums: (1 2 2 3 1)\n;; return: 2 (The degree is 2, and the shortest subarray with degree 2 is [2, 2])\n", "canonical_solution": "(let ((num-freq (make-hash-table :test 'equal))\n(first-occurrence (make-hash-table :test 'equal))\n(max-freq 0)\n(min-length most-positive-fixnum))\n;; Build frequency table and track first occurrence of each number.\n(cl-loop for i from 0 below (length nums) do\n(let ((num (nth i nums)))\n(puthash num (1+ (gethash num num-freq 0)) num-freq)\n(unless (gethash num first-occurrence)\n(puthash num i first-occurrence))))\n;; Determine the degree of the array.\n(maphash (lambda (key value)\n(setq max-freq (max max-freq value)))\nnum-freq)\n;; Find the shortest subarray with the same degree.\n(maphash (lambda (key freq)\n(when (= freq max-freq)\n(let* ((start (gethash key first-occurrence))\n(end (cl-position key nums :start start :from-end t))\n(length (+ 1 (- end start))))\n(setq min-length (min min-length length)))))\nnum-freq)\nmin-length))", "test": "(defun check-find-shortest-subarray-with-same-degree ()\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1 2 2 3 1)) 2))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1 2 2 3 1 4 2)) 6))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1 2 3 4 5)) 1))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(2 1 1 2 1 3 3 3 1 3)) 5))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1)) 1)))\n\n(check-find-shortest-subarray-with-same-degree)", "entry_point": "find-shortest-subarray-with-same-degree", "signature": "(defun find-shortest-subarray-with-same-degree (nums)", "docstring": "generate elisp code\nFunction to find the length of the shortest subarray with the same degree as the original array.\nArgs:\nnums: List of non-negative integers.\nReturns:\nThe length of the shortest subarray with the same degree.\nExample:\nnums: (1 2 2 3 1)\nreturn: 2 (The degree is 2, and the shortest subarray with degree 2 is [2, 2])\n", "instruction": "Write a Emacs Lisp function `(defun find-shortest-subarray-with-same-degree (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the length of the shortest subarray with the same degree as the original array.\nArgs:\nnums: List of non-negative integers.\nReturns:\nThe length of the shortest subarray with the same degree.\nExample:\nnums: (1 2 2 3 1)\nreturn: 2 (The degree is 2, and the shortest subarray with degree 2 is [2, 2])\n", "level": "hard", "raw_generation":"(defun find-shortest-subarray-with-same-degree (nums)\n  \"Return the length of the shortest subarray with the same degree as NUMs.\"\n  (let ((frequency (make-hash-table :test 'equal))   ; Stores frequency of each element\n        (first-seen (make-hash-table :test 'equal))  ; Tracks first occurrence index\n        (last-seen (make-hash-table :test 'equal))   ; Tracks last occurrence index\n        (max-degree 0)                                ; Maximum degree found\n        (min-length most-positive-fixnum))            ; Minimum length of subarray with same degree\n    \n    ;; Iterate over the nums list and populate frequency, first-seen, and last-seen tables\n    (cl-loop for num in nums\n             for i from 0\n             do\n             (puthash num (+ (gethash num frequency 0) 1) frequency)\n             (unless (gethash num first-seen)\n               (puthash num i first-seen))\n             (puthash num i last-seen)\n\n             ;; Update max degree if a new maximum is found\n             (when (> (gethash num frequency) max-degree)\n               (setq max-degree (gethash num frequency)))\n             )\n    \n    ;; Find the shortest subarray with the same degree as `max-degree`\n    (maphash (lambda (num freq)\n               (when (= freq max-degree)\n                 (let ((start-index (gethash num first-seen))\n                       (end-index (gethash num last-seen)))\n                   ;; Calculate current subarray length and update min-length if shorter\n                   (setq min-length (min min-length (- end-index start-index -1))))))\n             frequency)\n\n    min-length))"}
{"task_id": "Emacs Lisp/10", "prompt": "(require 'cl-lib)\n\n(defun binary-search (nums target)\n\n;; generate elisp code\n;; Function to perform binary search on a sorted array.\n;; Args:\n;; nums: A sorted list of integers.\n;; target: The target integer to search for.\n;; Returns:\n;; The index of target in nums if found, -1 otherwise.\n;; Example:\n;; nums: (-1 0 3 5 9 12), target: 9\n;; return: 4", "canonical_solution": "(let ((low 0) (high (1- (length nums))))\n(catch 'found\n(while (<= low high)\n(let ((mid (+ low (/ (- high low) 2))))\n(cond\n((= (nth mid nums) target) (throw 'found mid))\n((< (nth mid nums) target) (setq low (1+ mid)))\n(t (setq high (1- mid))))))\n-1)))", "test": "(defun check-binary-search ()\n(cl-assert (equal (binary-search '(-1 0 3 5 9 12) 9) 4))\n(cl-assert (equal (binary-search '(-1 0 3 5 9 12) 2) -1))\n(cl-assert (equal (binary-search '(1 2 3 4 5 6) 4) 3))\n(cl-assert (equal (binary-search '(1 2 3 4 5 6) 6) 5))\n(cl-assert (equal (binary-search '(1) 1) 0))\n(cl-assert (equal (binary-search '() 1) -1)))\n\n(check-binary-search)", "entry_point": "binary-search", "signature": "(defun binary-search (nums target)", "docstring": "generate elisp code\nFunction to perform binary search on a sorted array.\nArgs:\nnums: A sorted list of integers.\ntarget: The target integer to search for.\nReturns:\nThe index of target in nums if found, -1 otherwise.\nExample:\nnums: (-1 0 3 5 9 12), target: 9\nreturn: 4", "instruction": "Write a Emacs Lisp function `(defun binary-search (nums target)` to solve the following problem:\ngenerate elisp code\nFunction to perform binary search on a sorted array.\nArgs:\nnums: A sorted list of integers.\ntarget: The target integer to search for.\nReturns:\nThe index of target in nums if found, -1 otherwise.\nExample:\nnums: (-1 0 3 5 9 12), target: 9\nreturn: 4", "level": "easy", "raw_generation":"(defun binary-search (nums target)\n  \"Perform binary search on a sorted array.\nNums is a sorted list of integers, and target is the integer to search for.\nReturns the index of target in nums if found, -1 otherwise.\"\n  (let ((left 0)\n        (right (1- (length nums))))\n    (while (<= left right)\n      (let* ((mid (+ left (/ (- right left) 2)))\n             (mid-value (nth mid nums)))\n        (cond\n         ((= mid-value target) mid)\n         ((< mid-value target) (setq left (1+ mid)))\n         (t (setq right (1- mid))))))\n    -1))"}
{"task_id": "Emacs Lisp/11", "prompt": "(require 'cl-lib)\n\n(defun is-last-character-one-bit (bits)\n;; generate elisp code\n;; Function to determine if the last character in a binary array must be a one-bit character.\n;; Args:\n;; bits: List of integers representing the binary array.\n;; Returns:\n;; t if the last character is a one-bit character, nil otherwise.\n;; Example:\n;; bits: (1 0 0)\n;; return: t (The last character is \"0\", which is a one-bit character)", "canonical_solution": "(let ((i 0))\n(while (< i (1- (length bits)))\n(setq i (+ i (if (= (nth i bits) 1) 2 1))))\n(= i (1- (length bits)))))", "test": "(defun check-is-last-character-one-bit ()\n(cl-assert (equal (is-last-character-one-bit '(1 0 0)) t))\n(cl-assert (equal (is-last-character-one-bit '(1 1 1 0)) nil))\n(cl-assert (equal (is-last-character-one-bit '(0)) t))\n(cl-assert (equal (is-last-character-one-bit '(1 0)) nil))\n(cl-assert (equal (is-last-character-one-bit '(1 1 0)) t)))\n\n(check-is-last-character-one-bit)", "entry_point": "is-last-character-one-bit", "signature": "(defun is-last-character-one-bit (bits)", "docstring": "generate elisp code\nFunction to determine if the last character in a binary array must be a one-bit character.\nArgs:\nbits: List of integers representing the binary array.\nReturns:\nt if the last character is a one-bit character, nil otherwise.\nExample:\nbits: (1 0 0)\nreturn: t (The last character is \"0\", which is a one-bit character)", "instruction": "Write a Emacs Lisp function `(defun is-last-character-one-bit (bits)` to solve the following problem:\ngenerate elisp code\nFunction to determine if the last character in a binary array must be a one-bit character.\nArgs:\nbits: List of integers representing the binary array.\nReturns:\nt if the last character is a one-bit character, nil otherwise.\nExample:\nbits: (1 0 0)\nreturn: t (The last character is \"0\", which is a one-bit character)", "level": "easy", "raw_generation":"(defun is-last-character-one-bit (bits)\n  \"Determine if the last character in BITS must be a one-bit character.\nBITS is a list of integers representing the binary array.\"\n  (let ((n (length bits))\n        (i 0))\n    (while (< i (- n 1))\n      (if (= (nth i bits) 1)\n          (setq i (+ i 2))\n        (setq i (+ i 1))))\n    (= i (- n 1))))"}
{"task_id": "Emacs Lisp/12", "prompt": "(require 'cl-lib)\n\n(defun find-center-index (nums)\n;; generate elisp code\n;; Function to find the center index of an array.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The center index if it exists, -1 otherwise.\n;; Example:\n;; nums: (1 7 3 6 5 6)\n;; return: 3 (Because the sum of the elements to the left of index 3 is equal to the sum of the elements to the right)", "canonical_solution": "(let ((total-sum (apply '+ nums))\n(left-sum 0))\n(catch 'center-found\n(cl-loop for i from 0 below (length nums) do\n(if (= left-sum (- total-sum left-sum (nth i nums)))\n(throw 'center-found i)\n(setq left-sum (+ left-sum (nth i nums)))))\n-1)))", "test": "(defun check-find-center-index ()\n(cl-assert (equal (find-center-index '(1 7 3 6 5 6)) 3))\n(cl-assert (equal (find-center-index '(1 2 3)) -1))\n(cl-assert (equal (find-center-index '(2 1 -1)) 0))\n(cl-assert (equal (find-center-index '(-1 -1 -1 -1 -1 0)) 2))\n(cl-assert (equal (find-center-index '(1)) 0)))\n\n(check-find-center-index)", "entry_point": "find-center-index", "signature": "(defun find-center-index (nums)", "docstring": "generate elisp code\nFunction to find the center index of an array.\nArgs:\nnums: List of integers.\nReturns:\nThe center index if it exists, -1 otherwise.\nExample:\nnums: (1 7 3 6 5 6)\nreturn: 3 (Because the sum of the elements to the left of index 3 is equal to the sum of the elements to the right)", "instruction": "Write a Emacs Lisp function `(defun find-center-index (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the center index of an array.\nArgs:\nnums: List of integers.\nReturns:\nThe center index if it exists, -1 otherwise.\nExample:\nnums: (1 7 3 6 5 6)\nreturn: 3 (Because the sum of the elements to the left of index 3 is equal to the sum of the elements to the right)", "level": "easy", "raw_generation":"(defun find-center-index (nums)\n  \"Find the center index where sums on both sides are equal.\"\n  (let ((total-sum (apply #'+ nums)) ; Calculate total sum of list\n        (left-sum 0))                ; Initialize left sum to zero\n    (cl-loop for i from 0 below (length nums) do\n             ;; Subtract current element from total to get right sum at index i\n             (let ((right-sum (- total-sum left-sum (nth i nums))))\n               (when (= left-sum right-sum) ; Check if left and right sums are equal\n                 (return-from find-center-index i))) ; Return current index\n             ;; Update the left sum by adding current element to it\n             (setq left-sum (+ left-sum (nth i nums)))))\n  -1)"}
{"task_id": "Emacs Lisp/13", "prompt": "(require 'cl-lib)\n\n(defun flood-fill (image sr sc new-color)\n;; generate elisp code\n;; Function to perform flood fill on an image.\n;; Args:\n;; image: A 2D list of integers representing the image.\n;; sr: Starting row index.\n;; sc: Starting column index.\n;; new-color: The new color to apply.\n;; Returns:\n;; The image after performing the flood fill.\n;; Example:\n;; image: ((1 1 1) (1 1 0) (1 0 1)), sr: 1, sc: 1, new-color: 2\n;; return: ((2 2 2) (2 2 0) (2 0 1))", "canonical_solution": "(let ((original-color (nth sc (nth sr image))))\n(when (/= original-color new-color)\n(flood-fill-helper image sr sc original-color new-color))\nimage))\n\n(defun flood-fill-helper (image sr sc original-color new-color)\n\"Helper function for flood-fill.\"\n(when (and (>= sr 0) (< sr (length image))\n(>= sc 0) (< sc (length (nth 0 image)))\n(= (nth sc (nth sr image)) original-color))\n(setf (nth sc (nth sr image)) new-color)\n(flood-fill-helper image (1- sr) sc original-color new-color) ; Up\n(flood-fill-helper image (1+ sr) sc original-color new-color) ; Down\n(flood-fill-helper image sr (1- sc) original-color new-color) ; Left\n(flood-fill-helper image sr (1+ sc) original-color new-color)) ; Right\nnil)", "test": ";; Test cases\n(defun check-flood-fill ()\n(cl-assert (equal (flood-fill '((1 1 1) (1 1 0) (1 0 1)) 1 1 2) '((2 2 2) (2 2 0) (2 0 1))))\n(cl-assert (equal (flood-fill '((0 0 0) (0 0 0)) 0 0 2) '((2 2 2) (2 2 2))))\n(cl-assert (equal (flood-fill '((0 1 2) (1 1 1) (0 0 0)) 1 1 3) '((0 3 2) (3 3 3) (0 0 0)))))\n\n(check-flood-fill)", "entry_point": "flood-fill", "signature": "(defun flood-fill (image sr sc new-color)", "docstring": "generate elisp code\nFunction to perform flood fill on an image.\nArgs:\nimage: A 2D list of integers representing the image.\nsr: Starting row index.\nsc: Starting column index.\nnew-color: The new color to apply.\nReturns:\nThe image after performing the flood fill.\nExample:\nimage: ((1 1 1) (1 1 0) (1 0 1)), sr: 1, sc: 1, new-color: 2\nreturn: ((2 2 2) (2 2 0) (2 0 1))", "instruction": "Write a Emacs Lisp function `(defun flood-fill (image sr sc new-color)` to solve the following problem:\ngenerate elisp code\nFunction to perform flood fill on an image.\nArgs:\nimage: A 2D list of integers representing the image.\nsr: Starting row index.\nsc: Starting column index.\nnew-color: The new color to apply.\nReturns:\nThe image after performing the flood fill.\nExample:\nimage: ((1 1 1) (1 1 0) (1 0 1)), sr: 1, sc: 1, new-color: 2\nreturn: ((2 2 2) (2 2 0) (2 0 1))", "level": "hard", "raw_generation":"(defun flood-fill (image sr sc new-color)\n  \"Perform flood fill on IMAGE starting from (SR, SC) to NEW-COLOR.\"\n  (let* ((original-color (nth (nth sc (nth sr image)) (nth sr image)))\n         (rows (length image))\n         (cols (length (car image))))\n    \n    ;; If the original color is already the new color, do nothing.\n    (when (/= original-color new-color)\n      (cl-labels ((flood (r c)\n                  \"Recursive helper to fill adjacent pixels.\"\n                  (unless (or (< r 0) (>= r rows) (< c 0) (>= c cols))\n                    ;; Check if the current position is the original color.\n                    (when (= (nth c (nth r image)) original-color)\n                      ;; Change the color to new-color.\n                      (aset (nth r image) c new-color)\n                      ;; Recurse on adjacent pixels.\n                      (flood (+ r 1) c)\n                      (flood (- r 1) c)\n                      (flood r (+ c 1))\n                      (flood r (- c 1)))))))\n        \n        ;; Start the flood fill from the initial position.\n        (flood sr sc)\n      \n      image)))"}
{"task_id": "Emacs Lisp/14", "prompt": "(require 'cl-lib)\n\n(defun next-greatest-letter (letters target)\n;; generate elisp code\n;; Function to find the smallest character greater than the target in a sorted array.\n;; Args:\n;; letters: A sorted list of characters.\n;; target: The target character.\n;; Returns:\n;; The smallest character greater than the target, or the first character if none is greater.\n;; Example:\n;; letters: (\"c\" \"f\" \"j\"), target: \"a\"\n;; return: \"c\"", "canonical_solution": "(let ((letters-array (vconcat letters))) ; \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4\n(catch 'found\n(cl-loop for letter across letters-array do\n(when (string-greaterp letter target)\n(throw 'found letter)))\n(aref letters-array 0))))", "test": "(defun check-next-greatest-letter ()\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"a\") \"c\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"c\") \"f\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"d\") \"f\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"g\") \"j\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"j\") \"c\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"k\") \"c\")))\n\n(check-next-greatest-letter)", "entry_point": "next-greatest-letter", "signature": "(defun next-greatest-letter (letters target)", "docstring": "generate elisp code\nFunction to find the smallest character greater than the target in a sorted array.\nArgs:\nletters: A sorted list of characters.\ntarget: The target character.\nReturns:\nThe smallest character greater than the target, or the first character if none is greater.\nExample:\nletters: (\"c\" \"f\" \"j\"), target: \"a\"\nreturn: \"c\"", "instruction": "Write a Emacs Lisp function `(defun next-greatest-letter (letters target)` to solve the following problem:\ngenerate elisp code\nFunction to find the smallest character greater than the target in a sorted array.\nArgs:\nletters: A sorted list of characters.\ntarget: The target character.\nReturns:\nThe smallest character greater than the target, or the first character if none is greater.\nExample:\nletters: (\"c\" \"f\" \"j\"), target: \"a\"\nreturn: \"c\"", "level": "easy", "raw_generation":"(defun next-greatest-letter (letters target)\n  \"Return the smallest character in LETTERS that is greater than TARGET.\nIf no such character exists, wrap around to the beginning of the list.\"\n  (cl-loop for letter across letters\n           if (string> letter target)\n             return letter\n           finally return (aref letters 0)))"}
{"task_id": "Emacs Lisp/15", "prompt": "(require 'cl-lib)\n\n(defun dominant-index (nums)\n;; generate elisp code\n;; Function to find the index of the dominant element in the array.\n;; The dominant element is the largest element that is at least twice as large as every other number in the array.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The index of the dominant element if it exists, -1 otherwise.\n;; Example:\n;; nums: (3 6 1 0)\n;; return: 1 (6 is the largest element and is twice as large as the other elements)", "canonical_solution": "(let ((max-val most-negative-fixnum)\n(second-max-val most-negative-fixnum)\n(max-index -1))\n;; Find the largest and second-largest elements.\n(cl-loop for i from 0 below (length nums) do\n(let ((val (nth i nums)))\n(when (> val max-val)\n(setq second-max-val max-val)\n(setq max-val val)\n(setq max-index i))\n(when (and (> val second-max-val) (< val max-val))\n(setq second-max-val val))))\n;; Check if the largest element is at least twice as large as the second-largest element.\n(if (>= max-val (* 2 second-max-val))\nmax-index\n-1)))", "test": ";; Test cases\n(defun check-dominant-index ()\n(cl-assert (equal (dominant-index '(3 6 1 0)) 1))\n(cl-assert (equal (dominant-index '(1 2 3 4)) -1))\n(cl-assert (equal (dominant-index '(0 0 0 1)) 3))\n(cl-assert (equal (dominant-index '(1)) 0))\n(cl-assert (equal (dominant-index '(5 1 5 0 2)) 0)))\n\n(check-dominant-index)", "entry_point": "dominant-index", "signature": "(defun dominant-index (nums)", "docstring": "generate elisp code\nFunction to find the index of the dominant element in the array.\nThe dominant element is the largest element that is at least twice as large as every other number in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe index of the dominant element if it exists, -1 otherwise.\nExample:\nnums: (3 6 1 0)\nreturn: 1 (6 is the largest element and is twice as large as the other elements)", "instruction": "Write a Emacs Lisp function `(defun dominant-index (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the index of the dominant element in the array.\nThe dominant element is the largest element that is at least twice as large as every other number in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe index of the dominant element if it exists, -1 otherwise.\nExample:\nnums: (3 6 1 0)\nreturn: 1 (6 is the largest element and is twice as large as the other elements)", "level": "hard", "raw_generation":"(defun dominant-index (nums)\n  \"Find the index of the dominant element in the list NUMS.\"\n  (if (< (length nums) 2)\n      ;; If there is only one or no elements, return -1 if empty, 0 otherwise\n      (-if-empty nums -1 0)\n    ;; Initialize variables to track the largest and second-largest values.\n    (let ((max-val most-negative-fixnum)\n          (second-max most-negative-fixnum)\n          (max-index -1))\n      ;; Iterate over elements of NUMS, keeping track of the maximums\n      (cl-loop for i from 0 to (- (length nums) 1) do\n               (let ((current-val (nth i nums)))\n                 (when (> current-val max-val)\n                   ;; Update second-max before changing max-val\n                   (setq second-max max-val)\n                   (setq max-val current-val)\n                   (setq max-index i))\n                 (or (<= current-val max-val)\n                     (and (> current-val second-max)\n                          (setq second-max current-val)))))\n      ;; Check if the maximum value is at least twice the second largest.\n      (if (>= max-val (* 2 second-max))\n          max-index\n        -1))))"}
{"task_id": "Emacs Lisp/16", "prompt": "(require 'cl-lib)\n\n(defun is-toeplitz-matrix (matrix)\n;; generate elisp code\n;; Function to check if a matrix is a Toeplitz matrix.\n;; Args:\n;; matrix: A 2D list of integers.\n;; Returns:\n;; t if the matrix is a Toeplitz matrix, nil otherwise.\n;; Example:\n;; matrix: ((1 2 3 4) (5 1 2 3) (9 5 1 2))\n;; return: t (Each diagonal from top-left to bottom-right has the same elements)", "canonical_solution": "(let ((rows (length matrix))\n(cols (length (nth 0 matrix))))\n(catch 'not-toeplitz\n(cl-loop for row from 0 below (1- rows) do\n(cl-loop for col from 0 below (1- cols) do\n(unless (= (nth col (nth row matrix))\n(nth (1+ col) (nth (1+ row) matrix)))\n(throw 'not-toeplitz nil))))\nt)))", "test": "(defun check-is-toeplitz-matrix ()\n(cl-assert (equal (is-toeplitz-matrix '((1 2 3 4) (5 1 2 3) (9 5 1 2))) t))\n(cl-assert (equal (is-toeplitz-matrix '((1 2) (2 2))) nil))\n(cl-assert (equal (is-toeplitz-matrix '((1 2 3) (4 1 2) (5 4 1) (6 5 4))) t))\n(cl-assert (equal (is-toeplitz-matrix '((1))) t))\n(cl-assert (equal (is-toeplitz-matrix '((1 2) (1 2))) nil)))\n\n(check-is-toeplitz-matrix)", "entry_point": "is-toeplitz-matrix", "signature": "(defun is-toeplitz-matrix (matrix)", "docstring": "generate elisp code\nFunction to check if a matrix is a Toeplitz matrix.\nArgs:\nmatrix: A 2D list of integers.\nReturns:\nt if the matrix is a Toeplitz matrix, nil otherwise.\nExample:\nmatrix: ((1 2 3 4) (5 1 2 3) (9 5 1 2))\nreturn: t (Each diagonal from top-left to bottom-right has the same elements)", "instruction": "Write a Emacs Lisp function `(defun is-toeplitz-matrix (matrix)` to solve the following problem:\ngenerate elisp code\nFunction to check if a matrix is a Toeplitz matrix.\nArgs:\nmatrix: A 2D list of integers.\nReturns:\nt if the matrix is a Toeplitz matrix, nil otherwise.\nExample:\nmatrix: ((1 2 3 4) (5 1 2 3) (9 5 1 2))\nreturn: t (Each diagonal from top-left to bottom-right has the same elements)", "level": "easy", "raw_generation":"(defun is-toeplitz-matrix (matrix)\n  \"Check if the given MATRIX is a Toeplitz matrix.\"\n  (let* ((num-rows (length matrix))         ; Number of rows\n         (num-cols (length (car matrix))))  ; Assume all rows have same length\n    ;; Iterate over each element in the matrix except for the last row and column\n    (cl-loop for i from 0 below (- num-rows 1) do\n             (cl-loop for j from 0 below (- num-cols 1) do\n                      ;; Check if current element matches the next diagonal element\n                      (unless (= (aref matrix i j)\n                                 (aref matrix (1+ i) (1+ j)))\n                        ;; If any pair does not match, return nil\n                        (return-from is-toeplitz-matrix nil))))\n    ;; If all diagonals are consistent, return t\n    t))"}
{"task_id": "Emacs Lisp/17", "prompt": "(require 'cl-lib)\n\n(defun unique-morse-representations (words)\n;; generate elisp code\n;; Function to count the number of unique Morse code translations of words.\n;; Args:\n;; words: List of strings representing words.\n;; Returns:\n;; The number of unique Morse code translations.\n;; Example:\n;; words: (\"gin\" \"zen\" \"gig\" \"msg\")\n;; return: 2", "canonical_solution": "(let ((morse-alist '((\"a\" . \".-\") (\"b\" . \"-...\") (\"c\" . \"-.-.\") (\"d\" . \"-..\")\n(\"e\" . \".\") (\"f\" . \"..-.\") (\"g\" . \"--.\") (\"h\" . \"....\")\n(\"i\" . \"..\") (\"j\" . \".---\") (\"k\" . \"-.-\") (\"l\" . \".-..\")\n(\"m\" . \"--\") (\"n\" . \"-.\") (\"o\" . \"---\") (\"p\" . \".--.\")\n(\"q\" . \"--.-\") (\"r\" . \".-.\") (\"s\" . \"...\") (\"t\" . \"-\")\n(\"u\" . \"..-\") (\"v\" . \"...-\") (\"w\" . \".--\") (\"x\" . \"-..-\")\n(\"y\" . \"-.--\") (\"z\" . \"--..\")))\n(morse-set (make-hash-table :test 'equal)))\n;; Translate each word into Morse code and add to the set.\n(dolist (word words)\n(let ((morse-code (mapconcat (lambda (char)\n(cdr (assoc (string char) morse-alist)))\nword \"\")))\n(puthash morse-code t morse-set)))\n;; Count unique Morse code translations.\n(hash-table-count morse-set)))\n", "test": "(defun check-unique-morse-representations ()\n(cl-assert (equal (unique-morse-representations '(\"gin\" \"zen\" \"gig\" \"msg\")) 2))\n(cl-assert (equal (unique-morse-representations '(\"a\" \"b\" \"c\" \"d\")) 4))\n(cl-assert (equal (unique-morse-representations '(\"cab\" \"abc\" \"bca\")) 3)))\n\n(check-unique-morse-representations)", "entry_point": "unique-morse-representations", "signature": "(defun unique-morse-representations (words)", "docstring": "generate elisp code\nFunction to count the number of unique Morse code translations of words.\nArgs:\nwords: List of strings representing words.\nReturns:\nThe number of unique Morse code translations.\nExample:\nwords: (\"gin\" \"zen\" \"gig\" \"msg\")\nreturn: 2", "instruction": "Write a Emacs Lisp function `(defun unique-morse-representations (words)` to solve the following problem:\ngenerate elisp code\nFunction to count the number of unique Morse code translations of words.\nArgs:\nwords: List of strings representing words.\nReturns:\nThe number of unique Morse code translations.\nExample:\nwords: (\"gin\" \"zen\" \"gig\" \"msg\")\nreturn: 2", "level": "hard", "raw_generation":"(defun unique-morse-representations (words)\n  \"Return the number of unique Morse code representations for WORDS.\"\n  ;; Define the Morse code translations as a list corresponding to 'a' to 'z'.\n  (let ((morse-codes\n         [\".-\" \"-...\" \"-.-.\" \"-..\" \".\" \"..-.\" \"--.\" \"....\" \"..\" \".---\"\n          \"-.-\" \".-..\" \"--\" \"-.\" \"---\" \".--.\" \"--.-\" \".-.\" \"...\"\" -\"\n          \"..-\" \"...-\" \".--\" \"-..-\" \"-.--\" \"--..\"]))\n    \n    ;; Convert a single word to its Morse code representation.\n    (defun word-to-morse (word)\n      (let ((morse-word \"\"))\n        (dolist (char (string-to-list word) morse-word)\n          (setq morse-word \n                (concat morse-word (aref morse-codes (- (char-code char) ?a)))))))\n    \n    ;; Use a hash table to count unique Morse code representations.\n    (let ((unique-representations (make-hash-table :test 'equal))\n          (morse-translations))\n      ;; Generate the Morse code for each word and store it in the hash table.\n      (dolist (word words)\n        (let ((morse-code (word-to-morse word)))\n          (puthash morse-code t unique-representations)))\n\n      ;; Count the number of unique representations.\n      (maphash (lambda (_key _value) (setq morse-translations (1+ morse-translations)))\n               unique-representations)\n      \n      ;; Return the count of unique Morse code translations.\n      morse-translations)))"}
{"task_id": "Emacs Lisp/18", "prompt": "(require 'cl-lib)\n\n(defun most-common-word (paragraph banned)\n;; generate elisp code\n;; Function to find the most common non-banned word in a paragraph.\n;; Args:\n;; paragraph: A string containing words.\n;; banned: A list of strings representing banned words.\n;; Returns:\n;; The most common non-banned word in lowercase.\n;; Example:\n;; paragraph: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\n;; banned: (\"hit\")\n;; return: \"ball\"", "canonical_solution": "(let ((word-freq (make-hash-table :test 'equal))\n(banned-set (make-hash-table :test 'equal))\n(max-word nil)\n(max-count 0))\n;; Populate the banned words set.\n(dolist (word banned)\n(puthash (downcase word) t banned-set))\n;; Process the paragraph to count word frequency.\n(dolist (word (split-string (downcase paragraph) \"[^a-zA-Z]+\" t))\n(unless (gethash word banned-set)\n(puthash word (1+ (gethash word word-freq 0)) word-freq)\n(when (> (gethash word word-freq) max-count)\n(setq max-word word)\n(setq max-count (gethash word word-freq)))))\nmax-word))\n", "test": "(defun check-most-common-word ()\n(cl-assert (equal (most-common-word \"Bob hit a ball, the hit BALL flew far after it was hit.\" '(\"hit\")) \"ball\"))\n(cl-assert (equal (most-common-word \"a.\" '()) \"a\"))\n(cl-assert (equal (most-common-word \"a, a, a, a, b,b,b,c, c\" '(\"a\")) \"b\"))\n(cl-assert (equal (most-common-word \"Apple? Orange! Banana; Apple: Melon, Grape,\" '(\"melon\" \"grape\")) \"apple\")))\n\n(check-most-common-word)", "entry_point": "most-common-word", "signature": "(defun most-common-word (paragraph banned)", "docstring": "generate elisp code\nFunction to find the most common non-banned word in a paragraph.\nArgs:\nparagraph: A string containing words.\nbanned: A list of strings representing banned words.\nReturns:\nThe most common non-banned word in lowercase.\nExample:\nparagraph: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\nbanned: (\"hit\")\nreturn: \"ball\"", "instruction": "Write a Emacs Lisp function `(defun most-common-word (paragraph banned)` to solve the following problem:\ngenerate elisp code\nFunction to find the most common non-banned word in a paragraph.\nArgs:\nparagraph: A string containing words.\nbanned: A list of strings representing banned words.\nReturns:\nThe most common non-banned word in lowercase.\nExample:\nparagraph: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\nbanned: (\"hit\")\nreturn: \"ball\"", "level": "hard", "raw_generation":"(defun most-common-word (paragraph banned)\n  \"Find the most common non-banned word in PARAGRAPH.\nBANNED is a list of strings representing banned words.\"\n  (let* ((words (split-string paragraph \"[^a-zA-Z0-9]+\" t))\n         (word-counts (make-hash-table :test 'equal))\n         (max-count 0)\n         (most-common \"\"))\n    \n    ;; Count occurrences of non-banned words\n    (dolist (word words)\n      (let ((lower-word (downcase word)))\n        (when (and (> (length lower-word) 0)\n                   (not (member lower-word banned)))\n          (puthash lower-word (1+ (gethash lower-word word-counts 0)) word-counts)\n          (when (> (gethash lower-word word-counts) max-count)\n            (setq max-count (gethash lower-word word-counts))\n            (setq most-common lower-word)))))\n    \n    most-common))"}
{"task_id": "Emacs Lisp/19", "prompt": "(require 'cl-lib)\n\n(defun flip-and-invert-image (image)\n;; generate elisp code\n;; Function to flip and invert a binary matrix.\n;; Args:\n;; image: A 2D list of binary values (0s and 1s).\n;; Returns:\n;; The flipped and inverted image.\n;; Example:\n;; image: ((1 1 0) (1 0 1) (0 0 0))\n;; return: ((1 0 0) (0 1 0) (1 1 1))\n", "canonical_solution": "(mapcar (lambda (row)\n(mapcar (lambda (elem) (if (= elem 0) 1 0))\n(reverse row)))\nimage))", "test": "(defun check-flip-and-invert-image ()\n(cl-assert (equal (flip-and-invert-image '((1 1 0) (1 0 1) (0 0 0)))\n'((1 0 0) (0 1 0) (1 1 1))))\n(cl-assert (equal (flip-and-invert-image '((1 1 0 0) (1 0 0 1) (0 1 1 1) (1 0 1 0)))\n'((1 1 0 0) (0 1 1 0) (0 0 0 1) (1 0 1 0))))\n(cl-assert (equal (flip-and-invert-image '((0) (1)))\n'((1) (0))))\n(cl-assert (equal (flip-and-invert-image '((1)))\n'((0)))))\n\n(check-flip-and-invert-image)", "entry_point": "flip-and-invert-image", "signature": "(defun flip-and-invert-image (image)", "docstring": "generate elisp code\nFunction to flip and invert a binary matrix.\nArgs:\nimage: A 2D list of binary values (0s and 1s).\nReturns:\nThe flipped and inverted image.\nExample:\nimage: ((1 1 0) (1 0 1) (0 0 0))\nreturn: ((1 0 0) (0 1 0) (1 1 1))\n", "instruction": "Write a Emacs Lisp function `(defun flip-and-invert-image (image)` to solve the following problem:\ngenerate elisp code\nFunction to flip and invert a binary matrix.\nArgs:\nimage: A 2D list of binary values (0s and 1s).\nReturns:\nThe flipped and inverted image.\nExample:\nimage: ((1 1 0) (1 0 1) (0 0 0))\nreturn: ((1 0 0) (0 1 0) (1 1 1))\n", "level": "easy", "raw_generation":"(defun flip-and-invert-image (image)\n  \"Flip and invert a binary matrix IMAGE.\"\n  (mapcar\n   (lambda (row)\n     ;; Reverse the row, then map each element to its inverted value.\n     (mapcar (lambda (element) (- 1 element))\n             (nreverse row)))\n   image))"}
{"task_id": "Emacs Lisp/20", "prompt": "(require 'cl-lib)\n(defun lemonade-change (bills)\n;; generate elisp code\n;; Function to determine if it's possible to provide change for each customer at a lemonade stand.\n;; Args:\n;; bills: List of integers representing the bills paid by each customer.\n;; Returns:\n;; t if change can be provided to every customer, nil otherwise.\n;; Example:\n;; bills: (5 5 5 10 20)\n;; return: t", "canonical_solution": "(catch 'cannot-change\n(let ((five 0) (ten 0))\n(cl-loop for bill in bills\ndo (cond ((= bill 5)\n(setq five (1+ five)))\n((= bill 10)\n(if (= five 0)\n(throw 'cannot-change nil)\n(setq five (1- five))\n(setq ten (1+ ten))))\n((= bill 20)\n(cond ((and (> ten 0) (> five 0))\n(setq ten (1- ten))\n(setq five (1- five)))\n((>= five 3)\n(setq five (- five 3)))\n(t (throw 'cannot-change nil))))))\nt)))", "test": "(defun check-lemonade-change ()\n(cl-assert (equal (lemonade-change '(5 5 5 10 20)) t))\n(cl-assert (equal (lemonade-change '(5 5 10 10 20)) nil))\n(cl-assert (equal (lemonade-change '(5 5 10)) t))\n(cl-assert (equal (lemonade-change '(10 10)) nil))\n(cl-assert (equal (lemonade-change '(5 5 10 10 20 20 20 20 5 5)) nil)))\n\n(check-lemonade-change)", "entry_point": "lemonade-change", "signature": "(defun lemonade-change (bills)", "docstring": "generate elisp code\nFunction to determine if it's possible to provide change for each customer at a lemonade stand.\nArgs:\nbills: List of integers representing the bills paid by each customer.\nReturns:\nt if change can be provided to every customer, nil otherwise.\nExample:\nbills: (5 5 5 10 20)\nreturn: t", "instruction": "Write a Emacs Lisp function `(defun lemonade-change (bills)` to solve the following problem:\ngenerate elisp code\nFunction to determine if it's possible to provide change for each customer at a lemonade stand.\nArgs:\nbills: List of integers representing the bills paid by each customer.\nReturns:\nt if change can be provided to every customer, nil otherwise.\nExample:\nbills: (5 5 5 10 20)\nreturn: t", "level": "middle", "raw_generation":"(defun lemonade-change (bills)\n  \"Determine if it's possible to provide correct change for each customer.\"\n  (let ((five-count 0)\n        (ten-count 0))\n    (cl-loop for bill in bills do\n             (cond\n              ;; Case when the bill is $5\n              ((= bill 5)\n               (setq five-count (1+ five-count)))\n\n              ;; Case when the bill is $10\n              ((= bill 10)\n               (if (> five-count 0)\n                   (progn\n                     (setq five-count (1- five-count))\n                     (setq ten-count (1+ ten-count)))\n                 (return nil)))\n\n              ;; Case when the bill is $20\n              ((= bill 20)\n               (if (and (> ten-count 0) (> five-count 0))\n                   (progn\n                     (setq ten-count (1- ten-count))\n                     (setq five-count (1- five-count)))\n                 (if (>= five-count 3)\n                     (setq five-count (- five-count 3))\n                   (return nil))))\n\n              ;; Default case, which theoretically shouldn't happen if input is correct.\n              (t (return nil))))\n    t))"}
{"task_id": "Emacs Lisp/21", "prompt": "(require 'cl-lib)\n(defun find-substring-index (haystack needle)\n;; generate elisp code\n;; This function searches for the first occurrence of the string `needle` within the string `haystack`.\n;; It returns the zero-based index of the first occurrence of `needle` in `haystack`.\n;; If `needle` is not found within `haystack`, the function returns -1.\n;; Example Usage:\n;; (find-substring-index \"hello world\" \"world\") ; Returns 6", "canonical_solution": "(if (string= needle \"\")\n0\n(let ((index (cl-search needle haystack)))\n(if index index -1)))\n)", "test": "\n(defun test-find-substring-index ()\n(cl-assert (equal (find-substring-index \"hello world\" \"world\") 6))\n(cl-assert (equal (find-substring-index \"hello world\" \"hello\") 0))\n(cl-assert (equal (find-substring-index \"hello world\" \"abc\") -1))\n(cl-assert (equal (find-substring-index \"abcabcabc\" \"abc\") 0))\n(cl-assert (equal (find-substring-index \"abcabcabc\" \"cab\") 2))\n(cl-assert (equal (find-substring-index \"openai\" \"ai\") 4))\n(cl-assert (equal (find-substring-index \"openai\" \"\") 0)))\n\n(test-find-substring-index)", "entry_point": "find-substring-index", "signature": "(defun find-substring-index (haystack needle)", "docstring": "generate elisp code\nThis function searches for the first occurrence of the string `needle` within the string `haystack`.\nIt returns the zero-based index of the first occurrence of `needle` in `haystack`.\nIf `needle` is not found within `haystack`, the function returns -1.\nExample Usage:\n(find-substring-index \"hello world\" \"world\") ; Returns 6", "instruction": "Write a Emacs Lisp function `(defun find-substring-index (haystack needle)` to solve the following problem:\ngenerate elisp code\nThis function searches for the first occurrence of the string `needle` within the string `haystack`.\nIt returns the zero-based index of the first occurrence of `needle` in `haystack`.\nIf `needle` is not found within `haystack`, the function returns -1.\nExample Usage:\n(find-substring-index \"hello world\" \"world\") ; Returns 6", "level": "easy", "raw_generation":"(defun find-substring-index (haystack needle)\n  \"Search for NEEDLE in HAYSTACK and return its starting index, or -1 if not found.\"\n  (let* ((haystack-length (length haystack))\n         (needle-length (length needle)))\n    (if (> needle-length haystack-length)\n        -1\n      (cl-loop with i from 0 below (- haystack-length needle-length + 1)\n               when (string= (substring haystack i (+ i needle-length)) needle)\n               return i\n               finally return -1))))"}
{"task_id": "Emacs Lisp/22", "prompt": "(require 'cl-lib)\n\n(defun comet-group-match (comet-name group-name)\n;; generate elisp code\n;; This function determines whether a group should go with a comet based on their names.\n;; Both comet-name and group-name are strings of uppercase letters without spaces or punctuation.\n;; The function calculates the product of letter values (A=1, B=2, ..., Z=26) for both names.\n;; If the mod 47 of both products is equal, it returns \"GO\", else \"STAY\".\n;; Example Usage:\n;; (comet-group-match \"COMETQ\" \"HVNGAT\") ; Should return \"GO\"\n;; (comet-group-match \"ABC\" \"XYZ\") ; Should return \"STAY\"", "canonical_solution": "(let ((name-value (lambda (name)\n(cl-reduce (lambda (a b) (* a b))\n(mapcar (lambda (c) (- c 64)) name)))))\n(if (= (mod (funcall name-value comet-name) 47)\n(mod (funcall name-value group-name) 47))\n\"GO\"\n\"STAY\"))\n)", "test": "(defun test-comet-group-match ()\n(cl-assert (equal (comet-group-match \"COMETQ\" \"HVNGAT\") \"GO\"))\n(cl-assert (equal (comet-group-match \"ABC\" \"XYZ\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"HALLEY\" \"TEAM\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"SWIFT\" \"ROCKY\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"ORION\" \"ORION\") \"GO\"))\n(cl-assert (equal (comet-group-match \"VEGA\" \"NOVA\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"LYRA\" \"SIGMA\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"PULSAR\" \"QUARK\") \"STAY\")))\n\n(test-comet-group-match)", "entry_point": "comet-group-match", "signature": "(defun comet-group-match (comet-name group-name)", "docstring": "generate elisp code\nThis function determines whether a group should go with a comet based on their names.\nBoth comet-name and group-name are strings of uppercase letters without spaces or punctuation.\nThe function calculates the product of letter values (A=1, B=2, ..., Z=26) for both names.\nIf the mod 47 of both products is equal, it returns \"GO\", else \"STAY\".\nExample Usage:\n(comet-group-match \"COMETQ\" \"HVNGAT\") ; Should return \"GO\"\n(comet-group-match \"ABC\" \"XYZ\") ; Should return \"STAY\"", "instruction": "Write a Emacs Lisp function `(defun comet-group-match (comet-name group-name)` to solve the following problem:\ngenerate elisp code\nThis function determines whether a group should go with a comet based on their names.\nBoth comet-name and group-name are strings of uppercase letters without spaces or punctuation.\nThe function calculates the product of letter values (A=1, B=2, ..., Z=26) for both names.\nIf the mod 47 of both products is equal, it returns \"GO\", else \"STAY\".\nExample Usage:\n(comet-group-match \"COMETQ\" \"HVNGAT\") ; Should return \"GO\"\n(comet-group-match \"ABC\" \"XYZ\") ; Should return \"STAY\"", "level": "easy", "raw_generation":"(defun comet-group-match (comet-name group-name)\n  \"Determine whether a group should go with a comet based on their names.\"\n  \n  ;; Helper function to calculate the product of letter values for a name.\n  (defun name-product (name)\n    (cl-reduce '* (mapcar (lambda (char) (- (ord char) (ord ?A) +1)) name)))\n\n  ;; Calculate the products of letter values for both names.\n  (let ((comet-product (name-product comet-name))\n        (group-product (name-product group-name)))\n    \n    ;; Compare their mod 47 results and return \"GO\" or \"STAY\".\n    (if (= (% comet-product 47) (% group-product 47))\n        \"GO\"\n      \"STAY\")))"}
{"task_id": "Emacs Lisp/23", "prompt": "(require 'cl-lib)\n(defun goldbach-conjecture (N)\n;; This function tests Goldbach's conjecture for even numbers from 4 to N.\n;; Goldbach's conjecture states that every even number greater than 2 can be expressed as the sum of two prime numbers.\n;; For each even number, the function finds the pair of prime numbers that add up to it, preferring the pair with the smallest first number.\n;; Example Usage:\n;; (goldbach-conjecture 10) ; Returns '((4 2 2) (6 3 3) (8 3 5) (10 3 7))", "canonical_solution": "(cl-loop for i from 4 to N by 2\ncollect (cl-loop for j from 2 to i\nwhen (and (is-prime j) (is-prime (- i j)))\nreturn (list i j (- i j))))\n) (defun is-prime (n)\n\"Check if N is a prime number.\"\n(when (> n 1)\n(cl-loop for i from 2 to (sqrt n) never (zerop (mod n i)))))\n\n(defun goldbach-conjecture (N)\n\"Generate a list of even numbers from 4 to N with their Goldbach's pair.\"\n(cl-loop for i from 4 to N by 2\ncollect (cl-loop for j from 2 to i\nwhen (and (is-prime j) (is-prime (- i j)))\nreturn (list i j (- i j)))))", "test": "(defun test-goldbach-conjecture ()\n(cl-assert (equal (goldbach-conjecture 10) '((4 2 2) (6 3 3) (8 3 5) (10 3 7))))\n(cl-assert (equal (goldbach-conjecture 12) '((4 2 2) (6 3 3) (8 3 5) (10 3 7) (12 5 7))))\n(cl-assert (equal (goldbach-conjecture 0) nil))\n(cl-assert (equal (goldbach-conjecture 2) nil))\n(cl-assert (equal (goldbach-conjecture 4) '((4 2 2)))))\n\n(test-goldbach-conjecture)", "entry_point": "goldbach-conjecture", "signature": "(defun goldbach-conjecture (N)", "docstring": "This function tests Goldbach's conjecture for even numbers from 4 to N.\nGoldbach's conjecture states that every even number greater than 2 can be expressed as the sum of two prime numbers.\nFor each even number, the function finds the pair of prime numbers that add up to it, preferring the pair with the smallest first number.\nExample Usage:\n(goldbach-conjecture 10) ; Returns '((4 2 2) (6 3 3) (8 3 5) (10 3 7))", "instruction": "Write a Emacs Lisp function `(defun goldbach-conjecture (N)` to solve the following problem:\nThis function tests Goldbach's conjecture for even numbers from 4 to N.\nGoldbach's conjecture states that every even number greater than 2 can be expressed as the sum of two prime numbers.\nFor each even number, the function finds the pair of prime numbers that add up to it, preferring the pair with the smallest first number.\nExample Usage:\n(goldbach-conjecture 10) ; Returns '((4 2 2) (6 3 3) (8 3 5) (10 3 7))", "level": "hard", "raw_generation":"(defun is-prime (n)\n  \"Check if N is a prime number.\"\n  (if (< n 2)\n      nil\n    (let ((limit (floor (sqrt n))))\n      (catch 'not-prime\n        (dotimes (i (+ limit 1))\n          (when (and (> i 1) (= (mod n i) 0))\n            (throw 'not-prime t)))\n        t))))"}
{"task_id": "Emacs Lisp/24", "prompt": "(require 'cl-lib)\n(defun reverse-digits (n)\n;; This function takes an integer N and returns a new integer with its digits reversed.\n;; If the reversed integer would have leading zeros, these are removed in the returned integer.\n;; For example:\n;; (reverse-digits 123) ; Returns 321\n;; (reverse-digits -123); Returns -321\n;; (reverse-digits 1200); Returns 21\n;; (reverse-digits 0) ; Returns 0", "canonical_solution": "(let ((sign (if (< n 0) -1 1)))\n(* sign (string-to-number (reverse-string (number-to-string (abs n))))))\n)\n(defun reverse-string (str)\n\"Reverse a string STR.\"\n(apply 'string (reverse (string-to-list str))))", "test": "(defun test-reverse-digits ()\n(cl-assert (equal (reverse-digits 123) 321))\n(cl-assert (equal (reverse-digits -123) -321))\n(cl-assert (equal (reverse-digits 1200) 21))\n(cl-assert (equal (reverse-digits 0) 0))\n(cl-assert (equal (reverse-digits 5050) 505))\n(cl-assert (equal (reverse-digits -5050) -505)))\n\n(test-reverse-digits)", "entry_point": "reverse-digits", "signature": "(defun reverse-digits (n)", "docstring": "This function takes an integer N and returns a new integer with its digits reversed.\nIf the reversed integer would have leading zeros, these are removed in the returned integer.\nFor example:\n(reverse-digits 123) ; Returns 321\n(reverse-digits -123); Returns -321\n(reverse-digits 1200); Returns 21\n(reverse-digits 0) ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun reverse-digits (n)` to solve the following problem:\nThis function takes an integer N and returns a new integer with its digits reversed.\nIf the reversed integer would have leading zeros, these are removed in the returned integer.\nFor example:\n(reverse-digits 123) ; Returns 321\n(reverse-digits -123); Returns -321\n(reverse-digits 1200); Returns 21\n(reverse-digits 0) ; Returns 0", "level": "easy", "raw_generation":"(defun reverse-digits (n)\n  \"Reverse the digits of integer N, removing leading zeros in the reversed result.\"\n\n  ;; Convert number to string and handle negative sign if present\n  (let* ((str (if (< n 0)\n                  (substring (number-to-string (- n)) 1) ; Remove '-' for processing\n                (number-to-string n)))\n         ;; Reverse the string representation of digits\n         (rev-str (reverse str))\n         ;; Convert reversed string back to number, removing leading zeros automatically\n         (reversed-int (string-to-number rev-str)))\n\n    ;; Return the negative value if original was negative\n    (if (< n 0) (- reversed-int) reversed-int)))"}
{"task_id": "Emacs Lisp/25", "prompt": "(require 'cl-lib)\n(defun count-water-pockets (heights)\n;; This function takes a list of integers representing terrain heights and counts the number of low points where water can accumulate.\n;; A water pocket is defined as a low point surrounded by higher terrain on both sides.\n;; Example Usage:\n;; (count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) ; Returns 3\n;; (count-water-pockets '(0 2 2 1 2 0)) ; Returns 1\n;; (count-water-pockets '(0 3 3 3 0)) ; Returns 0", "canonical_solution": "(let ((count 0) (i 1) (len (length heights)))\n(while (< i (- len 1))\n(when (and (< (nth i heights) (nth (1- i) heights))\n(<= (nth i heights) (nth (1+ i) heights)))\n(setq count (1+ count))\n(while (and (< i (- len 1))\n(<= (nth i heights) (nth (1+ i) heights)))\n(setq i (1+ i)))) ; Continue checking next elements in case of consecutive low points\n(setq i (1+ i)))\ncount)\n)", "test": "(defun test-count-water-pockets ()\n(cl-assert (equal (count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) 3))\n(cl-assert (equal (count-water-pockets '(0 2 2 1 2 0)) 1))\n(cl-assert (equal (count-water-pockets '(0 3 3 3 0)) 0))\n(cl-assert (equal (count-water-pockets '(0 1 2 3 2 1 0)) 0))\n(cl-assert (equal (count-water-pockets '(0 1 0 1 0)) 1))\n)\n\n(test-count-water-pockets)", "entry_point": "count-water-pockets", "signature": "(defun count-water-pockets (heights)", "docstring": "This function takes a list of integers representing terrain heights and counts the number of low points where water can accumulate.\nA water pocket is defined as a low point surrounded by higher terrain on both sides.\nExample Usage:\n(count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) ; Returns 3\n(count-water-pockets '(0 2 2 1 2 0)) ; Returns 1\n(count-water-pockets '(0 3 3 3 0)) ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun count-water-pockets (heights)` to solve the following problem:\nThis function takes a list of integers representing terrain heights and counts the number of low points where water can accumulate.\nA water pocket is defined as a low point surrounded by higher terrain on both sides.\nExample Usage:\n(count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) ; Returns 3\n(count-water-pockets '(0 2 2 1 2 0)) ; Returns 1\n(count-water-pockets '(0 3 3 3 0)) ; Returns 0", "level": "middle", "raw_generation":"(defun count-water-pockets (heights)\n  \"Count the number of water pockets surrounded by higher terrain heights.\"\n  (let ((count 0))  ;; Initialize a counter for the pockets.\n    (dotimes (i (- (length heights) 1))  ;; Iterate over each element, except the last one.\n      (when (and (< (nth i heights) (nth (1+ i) heights))   ;; Check if current is lower than next\n                 (> (nth i heights) 0))                      ;; Ensure it's not zero height\n        (setq count (+ count 1))))                           ;; Increment the counter.\n    count))"}
{"task_id": "Emacs Lisp/26", "prompt": "(require 'cl-lib)\n(defun longest-consecutive-sequence (sequence)\n;; This function takes a list of integers (SEQUENCE) and returns the length of the longest consecutive number sequence.\n;; A consecutive number sequence is a series of numbers in which each number is one more than the previous number.\n;; Example Usage:\n;; (longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) ; Returns 5\n;; (longest-consecutive-sequence '(10 5 1 2 3)) ; Returns 3", "canonical_solution": "(let ((sorted-seq (cl-sort (copy-sequence sequence) '<))\n(max-length 1) (current-length 1))\n(cl-loop for i from 1 below (length sorted-seq)\ndo (if (= (1+ (nth (1- i) sorted-seq)) (nth i sorted-seq))\n(setq current-length (1+ current-length))\n(setq max-length (max max-length current-length))\n(setq current-length 1)))\n(max max-length current-length))\n)", "test": "(defun test-longest-consecutive-sequence ()\n(cl-assert (equal (longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) 5))\n(cl-assert (equal (longest-consecutive-sequence '(10 5 1 2 3)) 3))\n(cl-assert (equal (longest-consecutive-sequence '(7 7 7 7)) 1))\n(cl-assert (equal (longest-consecutive-sequence '(1 2 3 4 5)) 5))\n)\n\n(test-longest-consecutive-sequence)", "entry_point": "longest-consecutive-sequence", "signature": "(defun longest-consecutive-sequence (sequence)", "docstring": "This function takes a list of integers (SEQUENCE) and returns the length of the longest consecutive number sequence.\nA consecutive number sequence is a series of numbers in which each number is one more than the previous number.\nExample Usage:\n(longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) ; Returns 5\n(longest-consecutive-sequence '(10 5 1 2 3)) ; Returns 3", "instruction": "Write a Emacs Lisp function `(defun longest-consecutive-sequence (sequence)` to solve the following problem:\nThis function takes a list of integers (SEQUENCE) and returns the length of the longest consecutive number sequence.\nA consecutive number sequence is a series of numbers in which each number is one more than the previous number.\nExample Usage:\n(longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) ; Returns 5\n(longest-consecutive-sequence '(10 5 1 2 3)) ; Returns 3", "level": "middle", "raw_generation":"(defun longest-consecutive-sequence (sequence)\n  \"Returns the length of the longest consecutive number sequence in SEQUENCE.\"\n  ;; Convert the list to a hash-table for O(1) lookups.\n  (let ((num-set (make-hash-table :test 'equal)))\n    ;; Populate the hash-table with numbers from the sequence.\n    (dolist (num sequence)\n      (puthash num t num-set))\n    \n    (defun has-consecutive-p (start-num)\n      \"Checks if there is a consecutive number sequence starting from START-NUM.\"\n      (let ((current start-num))\n        ;; Traverse the consecutive numbers.\n        (while (gethash current num-set)\n          (setq current (+ current 1)))\n        (- current start-num)))\n    \n    (let ((max-length 0))\n      ;; Iterate through each number in sequence to find the max length of consecutive sequence.\n      (dolist (num sequence)\n        (when (= (mod num 2) 0) ; Only check for sequences that could be the smallest number in a potential longest sequence.\n          (let ((length (has-consecutive-p num)))\n            ;; Update maximum length if necessary.\n            (if (> length max-length)\n                (setq max-length length)))))\n      max-length)))"}
{"task_id": "Emacs Lisp/27", "prompt": "(require 'cl-lib)\n(defun max-pens (yuan jiao)\n;; This function calculates the maximum number of pens that can be bought given a certain amount of money.\n;; Each pen costs 1 yuan and 9 jiao. The function takes two arguments: yuan and jiao, \n;; representing the amount of money available.\n;; Example Usage:\n;; (max-pens 10 3) ; Returns 5, as 10 yuan and 3 jiao can buy a maximum of 5 pens", "canonical_solution": "(let ((total-jiao (+ (* yuan 10) jiao)))\n(/ total-jiao 19))\n)", "test": "(defun test-max-pens ()\n(cl-assert (equal (max-pens 10 3) 5))\n(cl-assert (equal (max-pens 5 0) 2))\n(cl-assert (equal (max-pens 20 1) 10))\n(cl-assert (equal (max-pens 0 19) 1))\n(cl-assert (equal (max-pens 0 18) 0))\n(cl-assert (equal (max-pens 1 8) 0)))\n\n(test-max-pens)", "entry_point": "max-pens", "signature": "(defun max-pens (yuan jiao)", "docstring": "This function calculates the maximum number of pens that can be bought given a certain amount of money.\nEach pen costs 1 yuan and 9 jiao. The function takes two arguments: yuan and jiao, \nrepresenting the amount of money available.\nExample Usage:\n(max-pens 10 3) ; Returns 5, as 10 yuan and 3 jiao can buy a maximum of 5 pens", "instruction": "Write a Emacs Lisp function `(defun max-pens (yuan jiao)` to solve the following problem:\nThis function calculates the maximum number of pens that can be bought given a certain amount of money.\nEach pen costs 1 yuan and 9 jiao. The function takes two arguments: yuan and jiao, \nrepresenting the amount of money available.\nExample Usage:\n(max-pens 10 3) ; Returns 5, as 10 yuan and 3 jiao can buy a maximum of 5 pens", "level": "easy", "raw_generation":"(defun max-pens (yuan jiao)\n  \"Calculate the maximum number of pens that can be bought given YUAN and JIAO.\"\n  ;; Convert total money into fen to avoid floating-point issues.\n  (let* ((total-fen (+ (* yuan 100) jiao))\n         (pen-price-in-fen 99) ; 1 yuan = 100 fen, so price is 100 + 9 = 99 fen\n         ;; Calculate the maximum number of pens that can be bought.\n         (max-pens-count (/ total-fen pen-price-in-fen)))\n    max-pens-count))"}
{"task_id": "Emacs Lisp/28", "prompt": "(require 'cl-lib)\n(defun calculate-electricity-bill (kwh)\n;; This function calculates the electricity bill based on a tiered rate structure.\n;; For the first 150 kWh, the rate is 0.4463 per kWh.\n;; For 151 to 400 kWh, the rate is 0.4663 per kWh.\n;; For above 400 kWh, the rate is 0.5663 per kWh.\n;; It takes an integer KWH representing the total kilowatt-hour usage.\n;; Example Usage:\n;; (calculate-electricity-bill 267) ; Should return 121.5 as the bill amount", "canonical_solution": "(let ((bill 0.0))\n(cond\n((<= kwh 150)\n(setq bill (* kwh 0.4463)))\n((<= kwh 400)\n(setq bill (+ (* 150 0.4463) (* (- kwh 150) 0.4663))))\n(t\n(setq bill (+ (* 150 0.4463) (* 250 0.4663) (* (- kwh 400) 0.5663)))))\n(format \"%.1f\" bill))\n)", "test": "(defun test-calculate-electricity-bill ()\n(cl-assert (equal (calculate-electricity-bill 267) \"121.5\"))\n(cl-assert (equal (calculate-electricity-bill 150) \"66.9\"))\n(cl-assert (equal (calculate-electricity-bill 400) \"183.5\"))\n)\n\n(test-calculate-electricity-bill)", "entry_point": "calculate-electricity-bill", "signature": "(defun calculate-electricity-bill (kwh)", "docstring": "This function calculates the electricity bill based on a tiered rate structure.\nFor the first 150 kWh, the rate is 0.4463 per kWh.\nFor 151 to 400 kWh, the rate is 0.4663 per kWh.\nFor above 400 kWh, the rate is 0.5663 per kWh.\nIt takes an integer KWH representing the total kilowatt-hour usage.\nExample Usage:\n(calculate-electricity-bill 267) ; Should return 121.5 as the bill amount", "instruction": "Write a Emacs Lisp function `(defun calculate-electricity-bill (kwh)` to solve the following problem:\nThis function calculates the electricity bill based on a tiered rate structure.\nFor the first 150 kWh, the rate is 0.4463 per kWh.\nFor 151 to 400 kWh, the rate is 0.4663 per kWh.\nFor above 400 kWh, the rate is 0.5663 per kWh.\nIt takes an integer KWH representing the total kilowatt-hour usage.\nExample Usage:\n(calculate-electricity-bill 267) ; Should return 121.5 as the bill amount", "level": "easy", "raw_generation":"(defun calculate-electricity-bill (kwh)\n  \"Calculate electricity bill based on tiered rate structure.\"\n  (let ((first-tier-limit 150)\n        (second-tier-limit (- 400 first-tier-limit))\n        (first-tier-rate 0.4463)\n        (second-tier-rate 0.4663)\n        (third-tier-rate 0.5663)\n        (bill-amount 0))\n    \n    ;; Calculate bill for the first tier\n    (when (<= kwh first-tier-limit)\n      (setq bill-amount (* kwh first-tier-rate)))\n\n    ;; Calculate bill for the second tier\n    (when (and (> kwh first-tier-limit)\n               (<= kwh (+ first-tier-limit second-tier-limit)))\n      (let ((kwh-in-second-tier (- kwh first-tier-limit)))\n        (setq bill-amount (+ bill-amount (* kwh-in-second-tier second-tier-rate)))))\n    \n    ;; Calculate bill for the third tier\n    (when (> kwh (+ first-tier-limit second-tier-limit))\n      (let ((kwh-in-third-tier (- kwh (+ first-tier-limit second-tier-limit))))\n        (setq bill-amount (+ bill-amount (* kwh-in-third-tier third-tier-rate)))))\n    \n    ;; Round the result to 2 decimal places\n    (/ (round (* bill-amount 100)) 100.0)))"}
{"task_id": "Emacs Lisp/29", "prompt": "(require 'cl-lib)\n(defun steps-to-swim-distance (distance)\n;; This function calculates the number of steps Xiaoyu needs to swim a certain DISTANCE.\n;; Xiaoyu's first step is 2 meters, and each subsequent step is 98% of the previous step.\n;; The function returns the total number of steps required to swim at least the given distance.\n;; Example Usage:\n;; (steps-to-swim-distance 4.3) ; Returns 3 as it takes 3 steps to swim at least 4.3 meters", "canonical_solution": "(let ((current-distance 0)\n(step-distance 2)\n(steps 0))\n(while (< current-distance distance)\n(setq current-distance (+ current-distance step-distance))\n(setq step-distance (* step-distance 0.98))\n(setq steps (1+ steps)))\nsteps)\n)", "test": "(defun test-steps-to-swim-distance ()\n(cl-assert (equal (steps-to-swim-distance 4.3) 3))\n(cl-assert (equal (steps-to-swim-distance 2) 1))\n(cl-assert (equal (steps-to-swim-distance 5) 3))\n(cl-assert (equal (steps-to-swim-distance 10) 6))\n(cl-assert (equal (steps-to-swim-distance 15.5) 9)))\n\n(test-steps-to-swim-distance)", "entry_point": "steps-to-swim-distance", "signature": "(defun steps-to-swim-distance (distance)", "docstring": "This function calculates the number of steps Xiaoyu needs to swim a certain DISTANCE.\nXiaoyu's first step is 2 meters, and each subsequent step is 98% of the previous step.\nThe function returns the total number of steps required to swim at least the given distance.\nExample Usage:\n(steps-to-swim-distance 4.3) ; Returns 3 as it takes 3 steps to swim at least 4.3 meters", "instruction": "Write a Emacs Lisp function `(defun steps-to-swim-distance (distance)` to solve the following problem:\nThis function calculates the number of steps Xiaoyu needs to swim a certain DISTANCE.\nXiaoyu's first step is 2 meters, and each subsequent step is 98% of the previous step.\nThe function returns the total number of steps required to swim at least the given distance.\nExample Usage:\n(steps-to-swim-distance 4.3) ; Returns 3 as it takes 3 steps to swim at least 4.3 meters", "level": "easy", "raw_generation":"(defun steps-to-swim-distance (distance)\n  \"Calculate the number of steps required to swim at least DISTANCE meters.\"\n  (let ((current-step-length 2.0)    ;; Starting step length in meters\n        (total-steps 0)              ;; Counter for total steps taken\n        (total-distance-swum 0.0))   ;; Accumulated distance swum\n\n    ;; Loop until we've swum at least the desired distance\n    (while (< total-distance-swum distance)\n      (incf total-steps)             ;; Increment step count\n      (setq total-distance-swum (+ total-distance-swum current-step-length))\n      (setq current-step-length (* current-step-length 0.98)))\n\n    ;; Return the number of steps taken to reach or exceed the desired distance\n    total-steps))"}
{"task_id": "Emacs Lisp/30", "prompt": "(require 'cl-lib)\n(defun total-swim-distance (start-day days)\n;; This function calculates the total distance swum by a fish, which swims 250 km per day except on weekends.\n;; The swimming starts on a day of the week given by START-DAY (1 for Monday, ..., 7 for Sunday) and continues for a number of DAYS.\n;; The function returns the total distance swum in kilometers.\n;; Example Usage:\n;; (total-swim-distance 3 10) ; Returns 2000, as the fish swims for 10 days starting from Wednesday", "canonical_solution": "(let ((distance 0) (day start-day))\n(dotimes (i days)\n(unless (or (= day 6) (= day 7)) ; 6 and 7 represent Saturday and Sunday\n(setq distance (+ distance 250)))\n(setq day (if (= day 7) 1 (1+ day)))) ; Cycle the day of the week\ndistance)\n)", "test": "(defun test-total-swim-distance ()\n(cl-assert (equal (total-swim-distance 3 10) 2000))\n(cl-assert (equal (total-swim-distance 1 7) 1250))\n(cl-assert (equal (total-swim-distance 6 2) 0))\n(cl-assert (equal (total-swim-distance 7 3) 500))\n(cl-assert (equal (total-swim-distance 4 14) 2500))\n(cl-assert (equal (total-swim-distance 1 0) 0)))\n\n(test-total-swim-distance)", "entry_point": "total-swim-distance", "signature": "(defun total-swim-distance (start-day days)", "docstring": "This function calculates the total distance swum by a fish, which swims 250 km per day except on weekends.\nThe swimming starts on a day of the week given by START-DAY (1 for Monday, ..., 7 for Sunday) and continues for a number of DAYS.\nThe function returns the total distance swum in kilometers.\nExample Usage:\n(total-swim-distance 3 10) ; Returns 2000, as the fish swims for 10 days starting from Wednesday", "instruction": "Write a Emacs Lisp function `(defun total-swim-distance (start-day days)` to solve the following problem:\nThis function calculates the total distance swum by a fish, which swims 250 km per day except on weekends.\nThe swimming starts on a day of the week given by START-DAY (1 for Monday, ..., 7 for Sunday) and continues for a number of DAYS.\nThe function returns the total distance swum in kilometers.\nExample Usage:\n(total-swim-distance 3 10) ; Returns 2000, as the fish swims for 10 days starting from Wednesday", "level": "easy", "raw_generation":"(defun total-swim-distance (start-day days)\n  \"Calculate total swim distance given START-DAY and DAYS.\nSTART-DAY: 1=Monday, ..., 7=Sunday.\nDAYS: Number of consecutive days to calculate for.\"\n  (let ((total-distance 0))\n    (dotimes (i days)\n      (let ((current-day (+ start-day i)))\n        (when (<= 1 (% current-day 7)) ; Check if not weekend\n          (setq total-distance (+ total-distance 250)))))\n    total-distance))"}
{"task_id": "Emacs Lisp/31", "prompt": "(require 'cl-lib)\n(defun calculate-scholarships (students)\n;; This function calculates the total scholarship amount for each student in a list of STUDENTS.\n;; Each student is represented as a list containing their name, final score, class score, whether they are a student leader (Y/N), \n;; whether they are from a western province (Y/N), and the number of papers published.\n;; The function returns a list of lists, each containing the student's name and their total scholarship amount.\n;; Example Usage:\n;; (calculate-scholarships '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1))) \n;; ; Returns (ChenRuiyi 9000 28700)", "canonical_solution": "(let ((max-scholarship 0) (max-student \"\") (total-scholarship 0))\n(dolist (student students)\n(let* ((name (nth 0 student))\n(avg-score (nth 1 student))\n(class-score (nth 2 student))\n(leader (string= (nth 3 student) \"Y\"))\n(western (string= (nth 4 student) \"Y\"))\n(papers (nth 5 student))\n(scholarship 0))\n(when (> avg-score 80)\n(when (>= papers 1)\n(setq scholarship (+ scholarship 8000)))\n(when (and (> avg-score 85) (> class-score 80))\n(setq scholarship (+ scholarship 4000)))\n(when (> avg-score 90)\n(setq scholarship (+ scholarship 2000)))\n(when (and (> avg-score 85) western)\n(setq scholarship (+ scholarship 1000)))\n(when (and (> class-score 80) leader)\n(setq scholarship (+ scholarship 850))))\n(setq total-scholarship (+ total-scholarship scholarship))\n(when (> scholarship max-scholarship)\n(setq max-scholarship scholarship)\n(setq max-student name))))\n(list max-student max-scholarship total-scholarship)))", "test": "(defun test-calculate-scholarships ()\n(let ((student-data '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1) (\"LiXin\" 92 88 \"N\" \"N\" 0) (\"ZhangQin\" 83 87 \"Y\" \"N\" 1))))\n(cl-assert (equal (calculate-scholarships student-data)'(\"ChenRuiyi\" 9000 28700))))\n)\n(test-calculate-scholarships)", "entry_point": "calculate-scholarships", "signature": "(defun calculate-scholarships (students)", "docstring": "This function calculates the total scholarship amount for each student in a list of STUDENTS.\nEach student is represented as a list containing their name, final score, class score, whether they are a student leader (Y/N), \nwhether they are from a western province (Y/N), and the number of papers published.\nThe function returns a list of lists, each containing the student's name and their total scholarship amount.\nExample Usage:\n(calculate-scholarships '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1))) \n; Returns (ChenRuiyi 9000 28700)", "instruction": "Write a Emacs Lisp function `(defun calculate-scholarships (students)` to solve the following problem:\nThis function calculates the total scholarship amount for each student in a list of STUDENTS.\nEach student is represented as a list containing their name, final score, class score, whether they are a student leader (Y/N), \nwhether they are from a western province (Y/N), and the number of papers published.\nThe function returns a list of lists, each containing the student's name and their total scholarship amount.\nExample Usage:\n(calculate-scholarships '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1))) \n; Returns (ChenRuiyi 9000 28700)", "level": "hard", "raw_generation":"(defun calculate-amount (final-score class-score leader-p west-province papers-count)\n  \"Calculate the scholarship amount for a single student.\"\n  ;; Calculate base score from scores and papers count\n  (+ (* final-score 100) \n     (* class-score 50) \n     (* papers-count 30)))"}
{"task_id": "Emacs Lisp/32", "prompt": "(require 'cl-lib)\n(defun verify-isbn (isbn)\n;; Verifies the correctness of an ISBN number. An ISBN is structured as x-xxx-xxxxx-x,\n;; where 'x' is a digit and '-' is a separator. The last digit is a checksum calculated\n;; as the sum of the first 9 digits multiplied by their position index (1 to 9),\n;; modulo 11. If the checksum is 10, it is represented as 'X'.\n;; This function checks if the given ISBN is valid and returns 'Right' if it is,\n;; or the corrected ISBN if it's not.\n;; Examples:\n;;>>> verify-isbn(\"0-123-45678-9\")\n;;\"Right\"\n;;>>> verify-isbn(\"0-321-14670-2\")\n;;\"0-321-14670-X\"", "canonical_solution": "(let ((clean-isbn (replace-regexp-in-string \"-\" \"\" isbn))\n(checksum 0))\n(cl-loop for i from 0 below 9\ndo (setq checksum (+ checksum (* (string-to-number (substring clean-isbn i (1+ i))) (1+ i)))))\n(setq checksum (mod checksum 11))\n(let ((correct-checksum (if (= checksum 10) \"X\" (number-to-string checksum))))\n(if (string= correct-checksum (substring clean-isbn 9))\n\"Right\"\n(concat (substring isbn 0 12) correct-checksum)))))", "test": "(defun test-verify-isbn ()\n(cl-assert (equal (verify-isbn \"0-670-82162-4\") \"Right\"))\n(princ (verify-isbn \"0-321-14670-2\"))\n(cl-assert (equal (verify-isbn \"0-321-14670-2\") \"0-321-14670-0\"))\n(cl-assert (equal (verify-isbn \"1-234-56789-X\") \"Right\"))\n(cl-assert (equal (verify-isbn \"1-234-56789-0\") \"1-234-56789-X\"))\n(cl-assert (equal (verify-isbn \"0-201-53082-1\") \"Right\"))\n(cl-assert (equal (verify-isbn \"0-201-53082-X\") \"0-201-53082-1\")))\n\n(test-verify-isbn)", "entry_point": "verify-isbn", "signature": "(defun verify-isbn (isbn)", "docstring": "Verifies the correctness of an ISBN number. An ISBN is structured as x-xxx-xxxxx-x,\nwhere 'x' is a digit and '-' is a separator. The last digit is a checksum calculated\nas the sum of the first 9 digits multiplied by their position index (1 to 9),\nmodulo 11. If the checksum is 10, it is represented as 'X'.\nThis function checks if the given ISBN is valid and returns 'Right' if it is,\nor the corrected ISBN if it's not.\nExamples:\n>>> verify-isbn(\"0-123-45678-9\")\n\"Right\"\n>>> verify-isbn(\"0-321-14670-2\")\n\"0-321-14670-X\"", "instruction": "Write a Emacs Lisp function `(defun verify-isbn (isbn)` to solve the following problem:\nVerifies the correctness of an ISBN number. An ISBN is structured as x-xxx-xxxxx-x,\nwhere 'x' is a digit and '-' is a separator. The last digit is a checksum calculated\nas the sum of the first 9 digits multiplied by their position index (1 to 9),\nmodulo 11. If the checksum is 10, it is represented as 'X'.\nThis function checks if the given ISBN is valid and returns 'Right' if it is,\nor the corrected ISBN if it's not.\nExamples:\n>>> verify-isbn(\"0-123-45678-9\")\n\"Right\"\n>>> verify-isbn(\"0-321-14670-2\")\n\"0-321-14670-X\"", "level": "middle", "raw_generation":"(defun verify-char (c)\n  \"Verify if C is a digit or one of the valid ISBN characters.\"\n  (or (and (>= c ?0) (<= c ?9))\n      (member c '(?-))))"}
{"task_id": "Emacs Lisp/33", "prompt": "(require 'cl-lib)\n(defun process-random-numbers (numbers)\n;; This function takes a list of random numbers and processes it by removing duplicates\n;; and then sorting the remaining numbers in ascending order.\n;; It returns a list where the first element is the count of unique numbers,\n;; and the second element is the sorted list of these unique numbers.\n;; Example:\n;;>>> process-random-numbers '(10 20 30 20 10)\n;;(3 (10 20 30))\n;;>>> process-random-numbers '(5 4 3 2 1 1)\n;;(5 (1 2 3 4 5))", "canonical_solution": "(let ((unique-numbers (cl-remove-duplicates (copy-sequence numbers))))\n(list (length unique-numbers) (sort unique-numbers '<))))", "test": "(defun test-process-random-numbers ()\n(cl-assert (equal (process-random-numbers '(10 20 30 20 10)) '(3 (10 20 30))))\n(cl-assert (equal (process-random-numbers '(5 4 3 2 1 1)) '(5 (1 2 3 4 5))))\n(cl-assert (equal (process-random-numbers '(55 23 67 23 90 100 90)) '(5 (23 55 67 90 100))))\n(cl-assert (equal (process-random-numbers '(1 2 3 4 5)) '(5 (1 2 3 4 5)))))\n\n(test-process-random-numbers)", "entry_point": "process-random-numbers", "signature": "(defun process-random-numbers (numbers)", "docstring": "This function takes a list of random numbers and processes it by removing duplicates\nand then sorting the remaining numbers in ascending order.\nIt returns a list where the first element is the count of unique numbers,\nand the second element is the sorted list of these unique numbers.\nExample:\n>>> process-random-numbers '(10 20 30 20 10)\n(3 (10 20 30))\n>>> process-random-numbers '(5 4 3 2 1 1)\n(5 (1 2 3 4 5))", "instruction": "Write a Emacs Lisp function `(defun process-random-numbers (numbers)` to solve the following problem:\nThis function takes a list of random numbers and processes it by removing duplicates\nand then sorting the remaining numbers in ascending order.\nIt returns a list where the first element is the count of unique numbers,\nand the second element is the sorted list of these unique numbers.\nExample:\n>>> process-random-numbers '(10 20 30 20 10)\n(3 (10 20 30))\n>>> process-random-numbers '(5 4 3 2 1 1)\n(5 (1 2 3 4 5))", "level": "easy", "raw_generation":"(defun process-random-numbers (numbers)\n  \"Processes a list of numbers by removing duplicates and sorting.\nReturns a list where the first element is the count of unique numbers,\nand the second element is the sorted list of these unique numbers.\"\n  (let* ((unique-numbers (delete-dups numbers)) ;; Remove duplicates\n         (sorted-unique-numbers (sort unique-numbers #'<))) ;; Sort in ascending order\n    (list (length sorted-unique-numbers) sorted-unique-numbers)))"}
{"task_id": "Emacs Lisp/34", "prompt": "(require 'cl-lib)\n(defun maximize-importance (budget items)\n;; This function takes a budget and a list of items, each with a price and importance rating,\n;; and calculates the maximum total importance within the budget.\n;; Each item is represented as a cons cell (price . importance).\n;; The function returns the maximum sum of price times importance for the selected items,\n;; without exceeding the budget.\n;; Example:\n;;>>> maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))\n;;4000\n;;>>> maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))\n;;1450", "canonical_solution": "(let ((dp (make-vector (1+ budget) 0)))\n(dolist (item items)\n(let ((price (car item))\n(importance (cdr item)))\n(cl-loop for j from budget downto price\ndo (setf (aref dp j) (max (aref dp j)\n(+ (aref dp (- j price)) (* price importance)))))))\n(aref dp budget))\n)", "test": "(defun test-maximize-importance ()\n(cl-assert (equal (maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))) 4000))\n(cl-assert (equal (maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))) 1450))\n(cl-assert (equal (maximize-importance 800 '((250 . 3) (350 . 4) (150 . 2))) 2450))\n(cl-assert (equal (maximize-importance 600 '((100 . 1) (200 . 2) (300 . 3))) 1400)))\n\n(test-maximize-importance)", "entry_point": "maximize-importance", "signature": "(defun maximize-importance (budget items)", "docstring": "This function takes a budget and a list of items, each with a price and importance rating,\nand calculates the maximum total importance within the budget.\nEach item is represented as a cons cell (price . importance).\nThe function returns the maximum sum of price times importance for the selected items,\nwithout exceeding the budget.\nExample:\n>>> maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))\n4000\n>>> maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))\n1450", "instruction": "Write a Emacs Lisp function `(defun maximize-importance (budget items)` to solve the following problem:\nThis function takes a budget and a list of items, each with a price and importance rating,\nand calculates the maximum total importance within the budget.\nEach item is represented as a cons cell (price . importance).\nThe function returns the maximum sum of price times importance for the selected items,\nwithout exceeding the budget.\nExample:\n>>> maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))\n4000\n>>> maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))\n1450", "level": "easy", "raw_generation":"(defun maximize-importance (budget items)\n  \"Calculate the maximum importance that can be achieved within BUDGET for ITEMS.\"\n  ;; Initialize a table for storing maximum importance values at each budget point\n  (let ((n (length items))\n        (dp (make-vector (+ budget 1) 0)))\n\n    ;; Iterate over all possible item combinations\n    (dolist (item items)\n      (let ((price (car item))\n            (importance (cdr item)))\n        ;; Traverse the table from right to left for each price and update dp\n        (dotimes (b (- budget 1 -1 price) -1) ; Start with current budget minus item's price down to 0\n          (aset dp (+ b price) \n                (max (aref dp (+ b price)) \n                     (+ importance (aref dp b)))))))\n\n    ;; The maximum importance value for the given budget is now in dp[budget]\n    (aref dp budget)))"}
{"task_id": "Emacs Lisp/35", "prompt": "(require 'cl-lib)\n(defun construct-fbi-tree (n binary-string)\n;; This function constructs an FBI tree from a given binary string of length 2^N and \n;; returns its postorder traversal. The tree nodes are of three types: 'B' for all 0s, \n;; 'I' for all 1s, and 'F' for a mix of 0s and 1s. The tree is built recursively \n;; by dividing the string into two equal halves until the base case (single character) is reached.\n;; Example:\n;;>>> construct-fbi-tree 2 \"1010\"\n;;\"IBBF\"\n;;>>> construct-fbi-tree 1 \"01\"\n;;\"FB\"", "canonical_solution": "(defun node-type (string)\n(cond ((string-match-p \"^[0]+$\" string) \"B\")\n((string-match-p \"^[1]+$\" string) \"I\")\n(t \"F\")))\n(defun construct-tree (string)\n(if (= (length string) 1)\n(node-type string)\n(let* ((mid (/ (length string) 2))\n(left (substring string 0 mid))\n(right (substring string mid))\n(left-tree (construct-tree left))\n(right-tree (construct-tree right)))\n(concat left-tree right-tree (node-type string)))))\n(construct-tree binary-string))", "test": "(defun test-construct-fbi-tree ()\n(princ(construct-fbi-tree 2 \"1010\"))\n(cl-assert (equal (construct-fbi-tree 2 \"1010\") \"IBFIBFF\"))\n(cl-assert (equal (construct-fbi-tree 1 \"01\") \"BIF\"))\n(cl-assert (equal (construct-fbi-tree 3 \"10001011\") \"IBFBBBFIBFIIIFF\"))\n(cl-assert (equal (construct-fbi-tree 2 \"1111\") \"IIIIIII\")))\n\n(test-construct-fbi-tree)", "entry_point": "construct-fbi-tree", "signature": "(defun construct-fbi-tree (n binary-string)", "docstring": "This function constructs an FBI tree from a given binary string of length 2^N and \nreturns its postorder traversal. The tree nodes are of three types: 'B' for all 0s, \n'I' for all 1s, and 'F' for a mix of 0s and 1s. The tree is built recursively \nby dividing the string into two equal halves until the base case (single character) is reached.\nExample:\n>>> construct-fbi-tree 2 \"1010\"\n\"IBBF\"\n>>> construct-fbi-tree 1 \"01\"\n\"FB\"", "instruction": "Write a Emacs Lisp function `(defun construct-fbi-tree (n binary-string)` to solve the following problem:\nThis function constructs an FBI tree from a given binary string of length 2^N and \nreturns its postorder traversal. The tree nodes are of three types: 'B' for all 0s, \n'I' for all 1s, and 'F' for a mix of 0s and 1s. The tree is built recursively \nby dividing the string into two equal halves until the base case (single character) is reached.\nExample:\n>>> construct-fbi-tree 2 \"1010\"\n\"IBBF\"\n>>> construct-fbi-tree 1 \"01\"\n\"FB\"", "level": "middle", "raw_generation":"(defun construct-fbi-tree (n binary-string)\n  \"Construct an FBI tree from BINARY-STRING of length 2^N and return its postorder traversal.\"\n  \n  ;; Helper function to determine node type based on substring\n  (defun node-type (str)\n    (let ((len (length str)))\n      (cond\n       ((string-match-p \"^0+$\" str) 'B)   ; All zeros, node is of type B\n       ((string-match-p \"^1+$\" str) 'I)   ; All ones, node is of type I\n       (t                               ; Mixed 0s and 1s, node is of type F\n        'F))))\n  \n  ;; Recursive function to construct the FBI tree and return postorder traversal\n  (defun build-tree-and-return-postorder (str)\n    (let* ((len (length str))\n           (node (if (<= len 1)\n                     (node-type str)   ; Base case: single character\n                   ;; Recursive case: divide and conquer\n                   (let* ((mid (/ len 2))\n                          (left-half (substring str 0 mid))\n                          (right-half (substring str mid)))\n                     (concat \n                      (build-tree-and-return-postorder left-half)\n                      (build-tree-and-return-postorder right-half)\n                      (symbol-name (node-type str))))))) ; Combine results for postorder\n      node))\n  \n  ;; Initial call to the recursive function with the binary string\n  (build-tree-and-return-postorder binary-string))"}
{"task_id": "Emacs Lisp/36", "prompt": "(require 'cl-lib)\n(defun mars-finger-permutation (n m current-permutation)\n;; This function calculates the new arrangement of a Martian's fingers, \n;; given the current permutation, the number of fingers, and a small integer to add. \n;; Martians use a unique counting method with their fingers, where each permutation \n;; of fingers represents a different number. The function finds the permutation that\n;; represents the number obtained by adding the given small integer to the number \n;; represented by the current permutation.\n;; Example:\n;;>>> mars-finger-permutation 5 3 '(1 2 3 4 5)\n;;(1 2 4 5 3)\n;;>>> mars-finger-permutation 3 2 '(1 2 3)\n;;(1 3 2)", "canonical_solution": "(let* ((factorial (lambda (x) (if (<= x 1) 1 (* x (funcall factorial (- x 1))))))\n(perm-to-number (lambda (perm)\n(let ((number 0) (digits (copy-sequence perm)))\n(cl-loop for i from 1 upto (length digits)\ndo (setq number (+ number (* (- (nth (1- i) digits) 1)\n(funcall factorial (- n i)))))\ndo (cl-loop for j from i below (length digits)\nwhen (> (nth j digits) (nth (1- i) digits))\ndo (setf (nth j digits) (- (nth j digits) 1))))\n(1+ number))))\n(number-to-perm (lambda (number)\n(let ((digits (number-sequence 1 n)) (perm '()))\n(cl-loop for i from 1 upto n\ndo (let* ((fact (funcall factorial (- n i)))\n(index (/ (- number 1) fact))\n(digit (nth index digits)))\n(push digit perm)\n(setq digits (delete digit digits))\n(setq number (- number (* index fact)))))\n(nreverse perm)))))\n(funcall number-to-perm (+ (funcall perm-to-number current-permutation) m))))", "test": "(defun test-mars-finger-permutation ()\n(cl-assert (equal (mars-finger-permutation 5 3 '(1 2 3 4 5)) '(1 2 4 5 3)))\n(cl-assert (equal (mars-finger-permutation 3 2 '(1 2 3)) '(2 1 3)))\n(cl-assert (equal (mars-finger-permutation 4 5 '(1 2 3 4)) '(1 4 3 2)))\n(cl-assert (equal (mars-finger-permutation 6 10 '(1 2 3 4 5 6)) '(1 2 4 6 3 5))))\n\n(test-mars-finger-permutation)", "entry_point": "mars-finger-permutation", "signature": "(defun mars-finger-permutation (n m current-permutation)", "docstring": "This function calculates the new arrangement of a Martian's fingers, \ngiven the current permutation, the number of fingers, and a small integer to add. \nMartians use a unique counting method with their fingers, where each permutation \nof fingers represents a different number. The function finds the permutation that\nrepresents the number obtained by adding the given small integer to the number \nrepresented by the current permutation.\nExample:\n>>> mars-finger-permutation 5 3 '(1 2 3 4 5)\n(1 2 4 5 3)\n>>> mars-finger-permutation 3 2 '(1 2 3)\n(1 3 2)", "instruction": "Write a Emacs Lisp function `(defun mars-finger-permutation (n m current-permutation)` to solve the following problem:\nThis function calculates the new arrangement of a Martian's fingers, \ngiven the current permutation, the number of fingers, and a small integer to add. \nMartians use a unique counting method with their fingers, where each permutation \nof fingers represents a different number. The function finds the permutation that\nrepresents the number obtained by adding the given small integer to the number \nrepresented by the current permutation.\nExample:\n>>> mars-finger-permutation 5 3 '(1 2 3 4 5)\n(1 2 4 5 3)\n>>> mars-finger-permutation 3 2 '(1 2 3)\n(1 3 2)", "level": "hard", "raw_generation":"(defun mars-finger-permutation (n m current-permutation)\n  \"Calculate new arrangement of Martian fingers.\"\n  (let* ((current-number (cl-reduce (lambda (acc x) (+ (* acc n) (1- x))) current-permutation))\n         (new-number (+ current-number m))\n         (result '()))\n    (dotimes (_ n result)\n      (setq new-number (% new-number factorial-cache))\n      (let ((digit (/ new-number factorial-cache)))\n        (push (1+ digit) result)\n        (setq new-number (- new-number (* digit factorial-cache))))\n      (setq factorial-cache (- n (length result))))))"}
{"task_id": "Emacs Lisp/37", "prompt": "(require 'cl-lib)\n(defun minimum-number-of-groups (price-limit prices)\n;; This function calculates the minimum number of groups needed to distribute souvenirs,\n;; given a list of their prices and a price limit per group. Each group can contain \n;; at most two souvenirs and the total price of souvenirs in each group cannot exceed the limit.\n;; The function sorts the prices in descending order and then pairs the highest priced item \n;; with the lowest priced item that fits within the limit.\n;; Example:\n;;>>> minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)\n;;6\n;;>>> minimum-number-of-groups 50 '(10 20 30 40 50)\n;;3", "canonical_solution": "(let ((sorted-prices (sort prices '>))\n(group-count 0))\n(while sorted-prices\n(setq group-count (1+ group-count))\n(let ((first-price (pop sorted-prices)))\n(when (and sorted-prices (<= (+ first-price (car (last sorted-prices))) price-limit))\n(setq sorted-prices (butlast sorted-prices)))))\ngroup-count))", "test": "(defun test-minimum-number-of-groups ()\n(cl-assert (equal (minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)) 6))\n(cl-assert (equal (minimum-number-of-groups 50 '(10 20 30 40 50)) 3))\n(cl-assert (equal (minimum-number-of-groups 200 '(100 150 80 60)) 3))\n(cl-assert (equal (minimum-number-of-groups 120 '(50 50 20 30)) 2)))\n\n(test-minimum-number-of-groups)", "entry_point": "minimum-number-of-groups", "signature": "(defun minimum-number-of-groups (price-limit prices)", "docstring": "This function calculates the minimum number of groups needed to distribute souvenirs,\ngiven a list of their prices and a price limit per group. Each group can contain \nat most two souvenirs and the total price of souvenirs in each group cannot exceed the limit.\nThe function sorts the prices in descending order and then pairs the highest priced item \nwith the lowest priced item that fits within the limit.\nExample:\n>>> minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)\n6\n>>> minimum-number-of-groups 50 '(10 20 30 40 50)\n3", "instruction": "Write a Emacs Lisp function `(defun minimum-number-of-groups (price-limit prices)` to solve the following problem:\nThis function calculates the minimum number of groups needed to distribute souvenirs,\ngiven a list of their prices and a price limit per group. Each group can contain \nat most two souvenirs and the total price of souvenirs in each group cannot exceed the limit.\nThe function sorts the prices in descending order and then pairs the highest priced item \nwith the lowest priced item that fits within the limit.\nExample:\n>>> minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)\n6\n>>> minimum-number-of-groups 50 '(10 20 30 40 50)\n3", "level": "easy"}
{"task_id": "Emacs Lisp/38", "prompt": "(require 'cl-lib)\n(defun count-and-sort-numbers (numbers)\n;; This function takes a list of natural numbers and counts the occurrences of each number.\n;; It then sorts these numbers in ascending order and returns a list of pairs. \n;; Each pair contains a number and its count. \n;; The list is sorted by the numbers from smallest to largest.\n;; Example:\n;;>>> count-and-sort-numbers '(2 4 2 4 5 100 2 100)\n;;((2 3) (4 2) (5 1) (100 2))", "canonical_solution": "(let ((counts (make-hash-table :test 'equal))\nkeys)\n;; Count the numbers\n(dolist (num numbers)\n(puthash num (1+ (gethash num counts 0)) counts))\n;; Collect keys\n(maphash (lambda (key value) (push key keys)) counts)\n;; Sort and return\n(sort (mapcar (lambda (key) (list key (gethash key counts))) keys)\n(lambda (a b) (< (car a) (car b))))))", "test": "(defun test-count-and-sort-numbers ()\n(cl-assert (equal (count-and-sort-numbers '(2 4 2 4 5 100 2 100)) '((2 3) (4 2) (5 1) (100 2))))\n(cl-assert (equal (count-and-sort-numbers '(1 2 3 3 3 2 1)) '((1 2) (2 2) (3 3))))\n(cl-assert (equal (count-and-sort-numbers '(5 4 3 2 1)) '((1 1) (2 1) (3 1) (4 1) (5 1))))\n)\n(test-count-and-sort-numbers)", "entry_point": "count-and-sort-numbers", "signature": "(defun count-and-sort-numbers (numbers)", "docstring": "This function takes a list of natural numbers and counts the occurrences of each number.\nIt then sorts these numbers in ascending order and returns a list of pairs. \nEach pair contains a number and its count. \nThe list is sorted by the numbers from smallest to largest.\nExample:\n>>> count-and-sort-numbers '(2 4 2 4 5 100 2 100)\n((2 3) (4 2) (5 1) (100 2))", "instruction": "Write a Emacs Lisp function `(defun count-and-sort-numbers (numbers)` to solve the following problem:\nThis function takes a list of natural numbers and counts the occurrences of each number.\nIt then sorts these numbers in ascending order and returns a list of pairs. \nEach pair contains a number and its count. \nThe list is sorted by the numbers from smallest to largest.\nExample:\n>>> count-and-sort-numbers '(2 4 2 4 5 100 2 100)\n((2 3) (4 2) (5 1) (100 2))", "level": "middle", "raw_generation":"(defun count-elements (lst)\n  \"Count occurrences of each element in LST and return an alist.\"\n  (let ((count-table (make-hash-table :test 'equal)))\n    (dolist (elem lst)\n      (puthash elem (+ 1 (gethash elem count-table 0)) count-table))\n    ;; Convert hash table to list of pairs\n    (let ((result nil))\n      (maphash (lambda (key value)\n                 (push (list key value) result))\n               count-table)\n      result)))"}
{"task_id": "Emacs Lisp/39", "prompt": "(require 'cl-lib)\n(defun swap-binary-halves (number)\n;; This function takes a non-negative integer that fits in a 32-bit binary representation.\n;; It swaps the first 16 bits (high bits) with the last 16 bits (low bits) and returns the new number in decimal format.\n;; The input number is first represented in 32-bit binary form (with leading zeros if necessary), \n;; then the high and low bits are swapped to form a new number.\n;; Example:\n;;>>> swap-binary-halves 1314520\n;;249036820", "canonical_solution": "(let* ((binary-str (integer-to-binary-string number 32))\n(high-bits (substring binary-str 0 16))\n(low-bits (substring binary-str 16)))\n(string-to-number (concat low-bits high-bits) 2)))\n(defun integer-to-binary-string (number bit-length)\n\"Convert an integer to a binary string with a fixed bit length.\"\n(let ((binary-str \"\"))\n(dotimes (i bit-length binary-str)\n(setq binary-str (concat (if (zerop (logand number (ash 1 i))) \"0\" \"1\") binary-str)))))", "test": "(defun test-swap-binary-halves ()\n(cl-assert (equal (swap-binary-halves 1314520) 249036820))\n(cl-assert (equal (swap-binary-halves 65535) 4294901760))\n(cl-assert (equal (swap-binary-halves 4294901760) 65535))\n(cl-assert (equal (swap-binary-halves 0) 0)))\n\n(test-swap-binary-halves)", "entry_point": "swap-binary-halves", "signature": "(defun swap-binary-halves (number)", "docstring": "This function takes a non-negative integer that fits in a 32-bit binary representation.\nIt swaps the first 16 bits (high bits) with the last 16 bits (low bits) and returns the new number in decimal format.\nThe input number is first represented in 32-bit binary form (with leading zeros if necessary), \nthen the high and low bits are swapped to form a new number.\nExample:\n>>> swap-binary-halves 1314520\n249036820", "instruction": "Write a Emacs Lisp function `(defun swap-binary-halves (number)` to solve the following problem:\nThis function takes a non-negative integer that fits in a 32-bit binary representation.\nIt swaps the first 16 bits (high bits) with the last 16 bits (low bits) and returns the new number in decimal format.\nThe input number is first represented in 32-bit binary form (with leading zeros if necessary), \nthen the high and low bits are swapped to form a new number.\nExample:\n>>> swap-binary-halves 1314520\n249036820", "level": "middle", "raw_generation":"(defun swap-binary-halves (number)\n  \"Swap the first and last 16 bits of NUMBER.\"\n  (let* ((binary-string (format \"%032b\" number))\n         (high-bits (substring binary-string 0 16))\n         (low-bits (substring binary-string 16))\n         (swapped-binary (concat low-bits high-bits)))\n    (string-to-number swapped-binary 2)))"}
{"task_id": "Emacs Lisp/40", "prompt": "(require 'cl-lib)\n\n(defun median-after-removing-extremes (numbers-list)\n  ;; Function to calculate the median of a list after removing the maximum and minimum values.\n  ;; This function takes a list of integers and returns the median of the list after removing the maximum and minimum values.\n  ;; If the list is empty or contains less than 3 elements, the function returns nil to indicate that the median cannot be calculated.\n  ;; Args:\n  ;;   numbers-list: A list of integers.\n  ;; Returns:\n  ;;   The median of the list after removing the maximum and minimum values, or nil if the list has less than 3 elements.\n  ;; Example Usage:\n  ;; (median-after-removing-extremes '(5 3 1 4 2)) ; Returns 3\n  ;; (median-after-removing-extremes '(1 2 3)) ; Returns 2\n  ;; (median-after-removing-extremes '(1)) ; Returns nil", "canonical_solution": "  (if (< (length numbers-list) 3)\n      nil\n    (let* ((sorted-list (cl-sort (cl-copy-list numbers-list) '<))\n           (trimmed-list (butlast (cdr sorted-list))))\n      (if (my-evenp (length trimmed-list))\n          (/ (+ (nth (/ (length trimmed-list) 2) trimmed-list)\n                (nth (- (/ (length trimmed-list) 2) 1) trimmed-list))\n             2)\n        (nth (/ (length trimmed-list) 2) trimmed-list)))))\n\n(defun my-evenp (n)\n  \"Check whether N is an even number.\"\n  (= 0 (% n 2)))", "test": "(defun check-median-after-removing-extremes ()\n  (cl-assert (equal (median-after-removing-extremes '(5 3 1 4 2)) 3))\n  (cl-assert (equal (median-after-removing-extremes '(1 2 3)) 2))\n  (cl-assert (equal (median-after-removing-extremes '(1)) nil))\n  (cl-assert (equal (median-after-removing-extremes '(7 5 3 9 1 6)) 5))\n  (cl-assert (equal (median-after-removing-extremes '(10 20 30 40 50)) 30)))\n\n(check-median-after-removing-extremes)", "entry_point": "median-after-removing-extremes", "signature": "(defun median-after-removing-extremes (numbers-list)", "docstring": " Function to calculate the median of a list after removing the maximum and minimum values.\nThis function takes a list of integers and returns the median of the list after removing the maximum and minimum values.\nIf the list is empty or contains less than 3 elements, the function returns nil to indicate that the median cannot be calculated.\nArgs:\n  numbers-list: A list of integers.\nReturns:\n  The median of the list after removing the maximum and minimum values, or nil if the list has less than 3 elements.\nExample Usage:\n(median-after-removing-extremes '(5 3 1 4 2)) ; Returns 3\n(median-after-removing-extremes '(1 2 3)) ; Returns 2\n(median-after-removing-extremes '(1)) ; Returns nil", "instruction": "Write a Emacs Lisp function `(defun median-after-removing-extremes (numbers-list)` to solve the following problem: Function to calculate the median of a list after removing the maximum and minimum values.\nThis function takes a list of integers and returns the median of the list after removing the maximum and minimum values.\nIf the list is empty or contains less than 3 elements, the function returns nil to indicate that the median cannot be calculated.\nArgs:\n  numbers-list: A list of integers.\nReturns:\n  The median of the list after removing the maximum and minimum values, or nil if the list has less than 3 elements.\nExample Usage:\n(median-after-removing-extremes '(5 3 1 4 2)) ; Returns 3\n(median-after-removing-extremes '(1 2 3)) ; Returns 2\n(median-after-removing-extremes '(1)) ; Returns nil", "level": "middle", "raw_generation":"(defun median-after-removing-extremes (numbers-list)\n  \"Calculate the median of a list after removing maximum and minimum values.\n\nThis function takes a list of integers and returns the median of\nthe modified list, where the maximum and minimum elements have been removed.\nIf the list is empty or contains less than 3 elements, return nil to indicate\nthat the calculation cannot be performed.\"\n  \n  ;; Check if the input list has fewer than 3 elements\n  (if (< (length numbers-list) 3)\n      nil\n    ;; Sort the list and remove the first and last element\n    (let* ((sorted-list (sort (copy-sequence numbers-list) 'integer<))\n           (trimmed-list (nbutlast (cdr sorted-list))))\n      ;; Calculate median of trimmed list\n      (/ (+ (nth (- (length trimmed-list) 1) trimmed-list)\n            (nth (if (oddp (length trimmed-list))\n                     (/ (1- (length trimmed-list)) 2)\n                   (/ (length trimmed-list) 2)) \n                 trimmed-list))\n         2.0))))"}
{"task_id": "Emacs Lisp/41", "prompt": "(require 'cl-lib)\n\n(defun calculate-expression (a b c)\n  ;; Function to calculate the value of the expression (a+b)\u00d7c.\n  ;; This function takes three integers a, b, and c, and returns the result of (a+b)\u00d7c.\n  ;; Args:\n  ;;   a: An integer.\n  ;;   b: An integer.\n  ;;   c: An integer.\n  ;; Returns:\n  ;;   The result of the expression (a+b)\u00d7c.\n  ;; Example Usage:\n  ;; (calculate-expression 1 2 3) ; Returns 9\n  ;; (calculate-expression -1 -2 2) ; Returns -6", "canonical_solution": "  (let ((sum (+ a b)))\n    (* sum c)))", "test": "(defun check-calculate-expression ()\n  (cl-assert (equal (calculate-expression 1 2 3) 9))\n  (cl-assert (equal (calculate-expression -1 -2 2) -6))\n  (cl-assert (equal (calculate-expression 0 0 1) 0))\n  (cl-assert (equal (calculate-expression 100 -100 0) 0))\n  (cl-assert (equal (calculate-expression 50 50 2) 200)))\n\n(check-calculate-expression)", "entry_point": "calculate-expression", "signature": "(defun calculate-expression (a b c)", "docstring": " Function to calculate the value of the expression (a+b)\u00d7c.\nThis function takes three integers a, b, and c, and returns the result of (a+b)\u00d7c.\nArgs:\n  a: An integer.\n  b: An integer.\n  c: An integer.\nReturns:\n  The result of the expression (a+b)\u00d7c.\nExample Usage:\n(calculate-expression 1 2 3) ; Returns 9\n(calculate-expression -1 -2 2) ; Returns -6", "instruction": "Write a Emacs Lisp function `(defun calculate-expression (a b c)` to solve the following problem: Function to calculate the value of the expression (a+b)\u00d7c.\nThis function takes three integers a, b, and c, and returns the result of (a+b)\u00d7c.\nArgs:\n  a: An integer.\n  b: An integer.\n  c: An integer.\nReturns:\n  The result of the expression (a+b)\u00d7c.\nExample Usage:\n(calculate-expression 1 2 3) ; Returns 9\n(calculate-expression -1 -2 2) ; Returns -6", "level": "easy", "raw_generation":"(defun calculate-expression (a b c)\n  \"Calculate the value of the expression (a + b)  c.\n  \n  Args:\n    a: An integer.\n    b: An integer.\n    c: An integer.\n    \n  Returns:\n    The result of the expression (a + b)  c.\"\n\n  ;; Calculate the sum of a and b\n  (let ((sum (+ a b)))\n    ;; Multiply the sum by c to get the final result\n    (* sum c)))"}
{"task_id": "Emacs Lisp/42", "prompt": "(require 'cl-lib)\n\n(defun print-ascii-code (char)\n  ;; Function to output the ASCII code of a given character.\n  ;; This function takes a single character (excluding space) as input and returns its ASCII code.\n  ;; Args:\n  ;;   char: A character (type: character).\n  ;; Returns:\n  ;;   The ASCII code of the character as an integer.\n  ;; Example Usage:\n  ;; (print-ascii-code ?A) ; Returns 65\n  ;; (print-ascii-code ?z) ; Returns 122", "canonical_solution": "  char)", "test": "(defun check-print-ascii-code ()\n  (cl-assert (equal (print-ascii-code ?A) 65))\n  (cl-assert (equal (print-ascii-code ?z) 122))\n  (cl-assert (equal (print-ascii-code ?0) 48))\n  (cl-assert (equal (print-ascii-code ?!) 33))\n  (cl-assert (equal (print-ascii-code ?~) 126)))\n\n(check-print-ascii-code)", "entry_point": "print-ascii-code", "signature": "(defun print-ascii-code (char)", "docstring": " Function to output the ASCII code of a given character.\nThis function takes a single character (excluding space) as input and returns its ASCII code.\nArgs:\n  char: A character (type: character).\nReturns:\n  The ASCII code of the character as an integer.\nExample Usage:\n(print-ascii-code ?A) ; Returns 65\n(print-ascii-code ?z) ; Returns 122", "instruction": "Write a Emacs Lisp function `(defun print-ascii-code (char)` to solve the following problem: Function to output the ASCII code of a given character.\nThis function takes a single character (excluding space) as input and returns its ASCII code.\nArgs:\n  char: A character (type: character).\nReturns:\n  The ASCII code of the character as an integer.\nExample Usage:\n(print-ascii-code ?A) ; Returns 65\n(print-ascii-code ?z) ; Returns 122", "level": "easy", "raw_generation":"(defun print-ascii-code (char)\n  \"Output the ASCII code of a given character.\"\n  (interactive \"cEnter a character: \") ; Interactive prompt for testing purpose, not part of the function definition\n  ;; Check if input is valid character\n  (if (characterp char)\n      (message \"%d\" (char-to-integer char)) ; Convert and print ASCII code\n    (message \"Invalid character\")))"}
{"task_id": "Emacs Lisp/43", "prompt": "(require 'cl-lib)\n\n(defun ascii-to-char (ascii-code)\n  ;; Function to convert an ASCII code to the corresponding character.\n  ;; This function takes an integer representing an ASCII code and returns the character it represents.\n  ;; Args:\n  ;;   ascii-code: An integer (the ASCII code).\n  ;; Returns:\n  ;;   The character corresponding to the ASCII code.\n  ;; Example Usage:\n  ;; (ascii-to-char 65) ; Returns \"A\"\n  ;; (ascii-to-char 97) ; Returns \"a\"", "canonical_solution": "  (char-to-string ascii-code))", "test": "(defun check-ascii-to-char ()\n  (cl-assert (equal (ascii-to-char 65) \"A\"))\n  (cl-assert (equal (ascii-to-char 97) \"a\"))\n  (cl-assert (equal (ascii-to-char 48) \"0\"))\n  (cl-assert (equal (ascii-to-char 33) \"!\"))\n  (cl-assert (equal (ascii-to-char 126) \"~\")))\n\n(check-ascii-to-char)", "entry_point": "ascii-to-char", "signature": "(defun ascii-to-char (ascii-code)", "docstring": " Function to convert an ASCII code to the corresponding character.\nThis function takes an integer representing an ASCII code and returns the character it represents.\nArgs:\n  ascii-code: An integer (the ASCII code).\nReturns:\n  The character corresponding to the ASCII code.\nExample Usage:\n(ascii-to-char 65) ; Returns \"A\"\n(ascii-to-char 97) ; Returns \"a\"", "instruction": "Write a Emacs Lisp function `(defun ascii-to-char (ascii-code)` to solve the following problem: Function to convert an ASCII code to the corresponding character.\nThis function takes an integer representing an ASCII code and returns the character it represents.\nArgs:\n  ascii-code: An integer (the ASCII code).\nReturns:\n  The character corresponding to the ASCII code.\nExample Usage:\n(ascii-to-char 65) ; Returns \"A\"\n(ascii-to-char 97) ; Returns \"a\"", "level": "easy", "raw_generation":"(defun ascii-to-char (ascii-code)\n  \"Convert ASCII code to corresponding character.\"\n  ;; Convert the integer representation of the ASCII code into a character\n  (string (character ascii-code)))"}
{"task_id": "Emacs Lisp/44", "prompt": "(require 'cl-lib)\n\n(defun int-bool-int-conversion (int-val)\n  ;; Function to convert an integer to a boolean and then back to an integer.\n  ;; This function takes an integer, converts it to a boolean value (non-zero becomes true, zero becomes false),\n  ;; and then converts this boolean value back to an integer (true becomes 1, false becomes 0).\n  ;; Args:\n  ;;   int-val: An integer value.\n  ;; Returns:\n  ;;   An integer after conversion to boolean and then back to integer.\n  ;; Example Usage:\n  ;; (int-bool-int-conversion 3) ; Returns 1\n  ;; (int-bool-int-conversion 0) ; Returns 0", "canonical_solution": "  (if (= int-val 0) 0 1))", "test": "(defun check-int-bool-int-conversion ()\n  (cl-assert (equal (int-bool-int-conversion 3) 1))\n  (cl-assert (equal (int-bool-int-conversion 0) 0))\n  (cl-assert (equal (int-bool-int-conversion -1) 1))\n  (cl-assert (equal (int-bool-int-conversion 100) 1))\n  (cl-assert (equal (int-bool-int-conversion -100) 1)))\n\n(check-int-bool-int-conversion)", "entry_point": "int-bool-int-conversion", "signature": "(defun int-bool-int-conversion (int-val)", "docstring": " Function to convert an integer to a boolean and then back to an integer.\nThis function takes an integer, converts it to a boolean value (non-zero becomes true, zero becomes false),\nand then converts this boolean value back to an integer (true becomes 1, false becomes 0).\nArgs:\n  int-val: An integer value.\nReturns:\n  An integer after conversion to boolean and then back to integer.\nExample Usage:\n(int-bool-int-conversion 3) ; Returns 1\n(int-bool-int-conversion 0) ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun int-bool-int-conversion (int-val)` to solve the following problem: Function to convert an integer to a boolean and then back to an integer.\nThis function takes an integer, converts it to a boolean value (non-zero becomes true, zero becomes false),\nand then converts this boolean value back to an integer (true becomes 1, false becomes 0).\nArgs:\n  int-val: An integer value.\nReturns:\n  An integer after conversion to boolean and then back to integer.\nExample Usage:\n(int-bool-int-conversion 3) ; Returns 1\n(int-bool-int-conversion 0) ; Returns 0", "level": "easy", "raw_generation":"(defun int-bool-int-conversion (int-val)\n  \"Convert an integer to a boolean and then back to an integer.\nArgs:\n  INT-VAL: An integer value.\n\nReturns:\n  An integer after conversion to boolean and then back to integer.\"\n  ;; Convert the integer to boolean (non-zero becomes true, zero becomes false)\n  (if int-val t nil) \n  ;; Convert the boolean back to an integer (true becomes 1, false becomes 0)\n  )"}
{"task_id": "Emacs Lisp/45", "prompt": "(require 'cl-lib)\n\n(defun reverse-three-digit-number (n)\n  ;; Function to reverse a three-digit number.\n  ;; This function takes a three-digit integer and returns its reverse.\n  ;; Note: Leading zeros in the result are not preserved when returned as an integer.\n  ;; Args:\n  ;;   n: A three-digit integer.\n  ;; Returns:\n  ;;   The reversed integer.\n  ;; Example Usage:\n  ;; (reverse-three-digit-number 358) ; Returns 853", "canonical_solution": "  (let* ((str-n (number-to-string n))\n         (reversed-str-n (reverse str-n))\n         (reversed-n (string-to-number (concat reversed-str-n))))\n    reversed-n))", "test": "(defun check-reverse-three-digit-number ()\n  (cl-assert (equal (reverse-three-digit-number 358) 853))\n  (cl-assert (equal (reverse-three-digit-number 678) 876))\n  (cl-assert (equal (reverse-three-digit-number 120) 21)))\n\n(check-reverse-three-digit-number)", "entry_point": "reverse-three-digit-number", "signature": "(defun reverse-three-digit-number (n)", "docstring": " Function to reverse a three-digit number.\nThis function takes a three-digit integer and returns its reverse.\nNote: Leading zeros in the result are not preserved when returned as an integer.\nArgs:\n  n: A three-digit integer.\nReturns:\n  The reversed integer.\nExample Usage:\n(reverse-three-digit-number 358) ; Returns 853", "instruction": "Write a Emacs Lisp function `(defun reverse-three-digit-number (n)` to solve the following problem: Function to reverse a three-digit number.\nThis function takes a three-digit integer and returns its reverse.\nNote: Leading zeros in the result are not preserved when returned as an integer.\nArgs:\n  n: A three-digit integer.\nReturns:\n  The reversed integer.\nExample Usage:\n(reverse-three-digit-number 358) ; Returns 853", "level": "easy", "raw_generation":"(defun reverse-three-digit-number (n)\n  \"Reverse the digits of a three-digit number N and return it as an integer.\"\n  ;; Extract each digit by using modulus and division operations.\n  (let ((hundreds (floor (/ n 100)))       ; Get the hundreds place\n        (tens (mod (floor (/ n 10)) 10))   ; Get the tens place\n        (units (mod n 10)))                ; Get the units place\n    ;; Construct the reversed number.\n    (+ (* units 100)                      ; Move units to hundreds place\n       (* tens 10)                        ; Move tens to tens place\n       hundreds)))"}
{"task_id": "Emacs Lisp/46", "prompt": "(require 'cl-lib)\n\n(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Function to calculate the nth term of an arithmetic sequence.\n  ;; Given the first two terms of an arithmetic sequence, this function computes the nth term.\n  ;; Args:\n  ;;   a1: The first term of the sequence.\n  ;;   a2: The second term of the sequence.\n  ;;   n: The term number to find.\n  ;; Returns:\n  ;;   The value of the nth term in the arithmetic sequence.\n  ;; Example Usage:\n  ;; (nth-term-arithmetic-sequence 1 4 100) ; Returns 298\n  ;; (nth-term-arithmetic-sequence 3 5 10) ; Returns 23", "canonical_solution": "  (let ((difference (- a2 a1)))\n    (+ a1 (* (1- n) difference))))", "test": "(defun check-nth-term-arithmetic-sequence ()\n  (cl-assert (equal (nth-term-arithmetic-sequence 1 4 100) 298))\n  (cl-assert (equal (nth-term-arithmetic-sequence 3 5 10) 21))\n  (cl-assert (equal (nth-term-arithmetic-sequence 5 7 1) 5))\n  (cl-assert (equal (nth-term-arithmetic-sequence -3 -5 3) -7))\n  (cl-assert (equal (nth-term-arithmetic-sequence 10 20 5) 50)))\n\n(check-nth-term-arithmetic-sequence)", "entry_point": "nth-term-arithmetic-sequence", "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)", "docstring": " Function to calculate the nth term of an arithmetic sequence.\nGiven the first two terms of an arithmetic sequence, this function computes the nth term.\nArgs:\n  a1: The first term of the sequence.\n  a2: The second term of the sequence.\n  n: The term number to find.\nReturns:\n  The value of the nth term in the arithmetic sequence.\nExample Usage:\n(nth-term-arithmetic-sequence 1 4 100) ; Returns 298\n(nth-term-arithmetic-sequence 3 5 10) ; Returns 23", "instruction": "Write a Emacs Lisp function `(defun nth-term-arithmetic-sequence (a1 a2 n)` to solve the following problem: Function to calculate the nth term of an arithmetic sequence.\nGiven the first two terms of an arithmetic sequence, this function computes the nth term.\nArgs:\n  a1: The first term of the sequence.\n  a2: The second term of the sequence.\n  n: The term number to find.\nReturns:\n  The value of the nth term in the arithmetic sequence.\nExample Usage:\n(nth-term-arithmetic-sequence 1 4 100) ; Returns 298\n(nth-term-arithmetic-sequence 3 5 10) ; Returns 23", "level": "easy", "raw_generation":"(defun nth-term-arithmetic-sequence (a1 a2 n)\n  \"Calculate the nth term of an arithmetic sequence with first term A1 and second term A2 for the N-th position.\"\n  ;; Calculate common difference\n  (let ((d (- a2 a1)))\n    ;; Formula to find the nth term: a_n = a_1 + (n-1) * d\n    (+ a1 (* (1- n) d))))"}
{"task_id": "Emacs Lisp/47", "prompt": "(require 'cl-lib)\n\n(defun multiply-a-b (a b)\n  ;; Function to multiply two positive integers A and B.\n  ;; This function takes two integers A and B as input and returns their product.\n  ;; The function ensures that the integers are within the specified range (1 <= A,B <= 50000).\n  ;; Args:\n  ;;   a: An integer, the first multiplicand.\n  ;;   b: An integer, the second multiplicand.\n  ;; Returns:\n  ;;   The product of A and B as an integer.\n  ;; Example Usage:\n  ;; (multiply-a-b 3 4) ; Returns 12\n  ;; (multiply-a-b 36 18) ; Returns 648", "canonical_solution": "  (* a b))", "test": "(defun check-multiply-a-b ()\n  (cl-assert (equal (multiply-a-b 3 4) 12))\n  (cl-assert (equal (multiply-a-b 36 18) 648))\n  (cl-assert (equal (multiply-a-b 1 50000) 50000))\n  (cl-assert (equal (multiply-a-b 250 200) 50000))\n  (cl-assert (equal (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)", "entry_point": "multiply-a-b", "signature": "(defun multiply-a-b (a b)", "docstring": " Function to multiply two positive integers A and B.\nThis function takes two integers A and B as input and returns their product.\nThe function ensures that the integers are within the specified range (1 <= A,B <= 50000).\nArgs:\n  a: An integer, the first multiplicand.\n  b: An integer, the second multiplicand.\nReturns:\n  The product of A and B as an integer.\nExample Usage:\n(multiply-a-b 3 4) ; Returns 12\n(multiply-a-b 36 18) ; Returns 648", "instruction": "Write a Emacs Lisp function `(defun multiply-a-b (a b)` to solve the following problem: Function to multiply two positive integers A and B.\nThis function takes two integers A and B as input and returns their product.\nThe function ensures that the integers are within the specified range (1 <= A,B <= 50000).\nArgs:\n  a: An integer, the first multiplicand.\n  b: An integer, the second multiplicand.\nReturns:\n  The product of A and B as an integer.\nExample Usage:\n(multiply-a-b 3 4) ; Returns 12\n(multiply-a-b 36 18) ; Returns 648", "level": "easy", "raw_generation":"(defun multiply-a-b (a b)\n  \"Multiply two positive integers A and B within the specified range [1,50000].\"\n\n  ;; Ensure that both inputs are within the valid range.\n  (when (or (< a 1) (> a 50000))\n    (error \"Invalid value for A: %d\" a))\n  \n  (when (or (< b 1) (> b 50000))\n    (error \"Invalid value for B: %d\" b))\n\n  ;; Return the product of A and B.\n  (* a b))"}
{"task_id": "Emacs Lisp/48", "prompt": "(require 'cl-lib)\n\n(defun power-of-two (n)\n  ;; Function to calculate 2 raised to the power of n.\n  ;; Given a non-negative integer n, this function returns the value of 2^n.\n  ;; Args:\n  ;;   n: A non-negative integer, the exponent to raise 2 by.\n  ;; Returns:\n  ;;   The result of 2 raised to the power of n as an integer.\n  ;; Constraints:\n  ;;   0 <= n < 31 to ensure the result is within the range of Emacs Lisp's integer.\n  ;; Example Usage:\n  ;; (power-of-two 3) ; Returns 8\n  ;; (power-of-two 5) ; Returns 32", "canonical_solution": "  (expt 2 n))", "test": "(defun check-power-of-two ()\n  (cl-assert (equal (power-of-two 3) 8))\n  (cl-assert (equal (power-of-two 5) 32))\n  (cl-assert (equal (power-of-two 0) 1))\n  (cl-assert (equal (power-of-two 10) 1024))\n  (cl-assert (equal (power-of-two 15) 32768)))\n\n(check-power-of-two)", "entry_point": "power-of-two", "signature": "(defun power-of-two (n)", "docstring": " Function to calculate 2 raised to the power of n.\nGiven a non-negative integer n, this function returns the value of 2^n.\nArgs:\n  n: A non-negative integer, the exponent to raise 2 by.\nReturns:\n  The result of 2 raised to the power of n as an integer.\nConstraints:\n  0 <= n < 31 to ensure the result is within the range of Emacs Lisp's integer.\nExample Usage:\n(power-of-two 3) ; Returns 8\n(power-of-two 5) ; Returns 32", "instruction": "Write a Emacs Lisp function `(defun power-of-two (n)` to solve the following problem: Function to calculate 2 raised to the power of n.\nGiven a non-negative integer n, this function returns the value of 2^n.\nArgs:\n  n: A non-negative integer, the exponent to raise 2 by.\nReturns:\n  The result of 2 raised to the power of n as an integer.\nConstraints:\n  0 <= n < 31 to ensure the result is within the range of Emacs Lisp's integer.\nExample Usage:\n(power-of-two 3) ; Returns 8\n(power-of-two 5) ; Returns 32", "level": "easy", "raw_generation":"(defun power-of-two (n)\n  \"Calculate 2 raised to the power of N.\n\nArgs:\n  n: A non-negative integer, the exponent to raise 2 by.\n\nReturns:\n  The result of 2 raised to the power of N as an integer.\"\n  (if (<= n 0)\n      1\n    (* 2 (power-of-two (- n 1)))))"}
{"task_id": "Emacs Lisp/49", "prompt": "(require 'cl-lib)\n\n(defun determine-sign (n)\n  ;; Function to determine the sign of an integer N.\n  ;; Given an integer N, this function returns 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\n  ;; Args:\n  ;;   n: An integer, the number to determine the sign of.\n  ;; Returns:\n  ;;   A string indicating whether the integer is 'positive', 'zero', or 'negative'.\n  ;; Example Usage:\n  ;; (determine-sign 95) ; Returns \"positive\"\n  ;; (determine-sign 0) ; Returns \"zero\"\n  ;; (determine-sign -10) ; Returns \"negative\"", "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((= n 0) \"zero\")\n        ((< n 0) \"negative\")))", "test": "(defun check-determine-sign ()\n  (cl-assert (equal (determine-sign 95) \"positive\"))\n  (cl-assert (equal (determine-sign 0) \"zero\"))\n  (cl-assert (equal (determine-sign -10) \"negative\"))\n  (cl-assert (equal (determine-sign 1) \"positive\"))\n  (cl-assert (equal (determine-sign -1) \"negative\")))\n\n(check-determine-sign)", "entry_point": "determine-sign", "signature": "(defun determine-sign (n)", "docstring": " Function to determine the sign of an integer N.\nGiven an integer N, this function returns 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\nArgs:\n  n: An integer, the number to determine the sign of.\nReturns:\n  A string indicating whether the integer is 'positive', 'zero', or 'negative'.\nExample Usage:\n(determine-sign 95) ; Returns \"positive\"\n(determine-sign 0) ; Returns \"zero\"\n(determine-sign -10) ; Returns \"negative\"", "instruction": "Write a Emacs Lisp function `(defun determine-sign (n)` to solve the following problem: Function to determine the sign of an integer N.\nGiven an integer N, this function returns 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\nArgs:\n  n: An integer, the number to determine the sign of.\nReturns:\n  A string indicating whether the integer is 'positive', 'zero', or 'negative'.\nExample Usage:\n(determine-sign 95) ; Returns \"positive\"\n(determine-sign 0) ; Returns \"zero\"\n(determine-sign -10) ; Returns \"negative\"", "level": "easy", "raw_generation":"(defun determine-sign (n)\n  \"Determine the sign of integer N. Return 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\"\n  (cond ((> n 0) \"positive\")    ; Check if n is greater than zero\n        ((< n 0) \"negative\")    ; Check if n is less than zero\n        (t \"zero\")))"}
{"task_id": "Emacs Lisp/50", "prompt": "(require 'cl-lib)\n(defun absolute-value (n)\n;; Function to calculate the absolute value of an integer.\n;; Args:\n;;   n: An integer whose absolute value is to be found. The absolute value of n should not exceed 10000.\n;; Returns:\n;;   The absolute value of n.\n;; Example Usage:\n;; (absolute-value -5) ; Returns 5\n;; (absolute-value 10) ; Returns 10\n;; (absolute-value 0)  ; Returns 0", "canonical_solution": "  (if (< n 0)\n      (- n)\n    n)\n)", "test": "(defun check-absolute-value ()\n  \"Test cases for absolute-value function.\"\n  (cl-assert (equal (absolute-value -5) 5))\n  (cl-assert (equal (absolute-value 10) 10))\n  (cl-assert (equal (absolute-value 0) 0))\n  (cl-assert (equal (absolute-value -10000) 10000))\n  (cl-assert (equal (absolute-value 9999) 9999)))\n\n(check-absolute-value)", "entry_point": "absolute-value", "signature": "(defun absolute-value (n)", "docstring": " Function to calculate the absolute value of an integer.\n Args:\n   n: An integer whose absolute value is to be found. The absolute value of n should not exceed 10000.\n Returns:\n   The absolute value of n.\n Example Usage:\n (absolute-value -5) ; Returns 5\n (absolute-value 10) ; Returns 10\n (absolute-value 0)  ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun absolute-value (n)` to solve the following problem: Function to calculate the absolute value of an integer.\n Args:\n   n: An integer whose absolute value is to be found. The absolute value of n should not exceed 10000.\n Returns:\n   The absolute value of n.\n Example Usage:\n (absolute-value -5) ; Returns 5\n (absolute-value 10) ; Returns 10\n (absolute-value 0)  ; Returns 0", "level": "easy", "raw_generation":"(defun absolute-value (n)\n  \"Calculate the absolute value of integer N, where |N| <= 10000.\"\n  ;; Check if n is negative. If so, return its positive counterpart.\n  (if (< n 0)\n      (- n)\n    ;; Otherwise, just return n as it's already non-negative or zero.\n    n))"}
